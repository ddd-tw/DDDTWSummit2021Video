0:00:00.000,0:00:05.560
Okay, the next talk of Foundation Track 
will begin in two minutes.

0:00:06.000,0:00:11.000
Dr. Carola will give a speech with 
"It's all about the domain, honey!

0:00:11.520,0:00:18.560
Experiences from 15 years of the Domain-Driven Design"
Okay, so you can scan the QR code 

0:00:19.200,0:00:26.880
on the top right and you can go to Slido and 
ask some questions. So, let's welcome Dr. Carola, Hello!

0:00:26.880,0:00:34.720
Good morning phone, good morning. I mean good 
morning from europe you know we have morning here.

0:00:36.480,0:00:43.840
Yeah, it's afternoon here.
Yeah, perfect.

0:00:46.880,0:00:49.360
Should I start um sharing my slides

0:00:50.320,0:00:57.840
Sure! Okay, so Carola can you try show your slides?
Yes sure here we go.

0:01:03.840,0:01:13.360
Can you see them?
Yes very good perfect you can start your speech, thank you.
Thank you, thank you very much.

0:01:13.360,0:01:24.960
Hi everybody, um in this talk I will show 
you how to build systems in a way that makes sense

0:01:24.960,0:01:34.240
for the business and um how Domain-Driven Design 
can help you to do that. Um, my name is Carola

0:01:35.520,0:01:44.640
and on Twitter you can find me under my 
handle @cairolali. I have studied computer science

0:01:45.680,0:01:54.320
at the University of Hamburg and I gained my 
diploma in 1995 and since then I have done a

0:01:54.320,0:02:03.360
lot of programming in C++, in Java even in 
Visual Basic and in C# of course as well and

0:02:03.360,0:02:11.520
I have done a lot of consulting taking planes to 
visit my customers and i work as an architect and

0:02:11.520,0:02:19.200
architectin this is the German female version 
of an architect and in 2008 I handed in my

0:02:20.240,0:02:28.240
PhD thesis with the title "Complexity of 
Software Architecture" I then turned um all

0:02:28.240,0:02:35.520
the things i found out in my doctor's thesis into 
a business model for my company um we evaluate

0:02:35.520,0:02:42.320
the complexity of software architectures and 
check whether they are sustainable and how many

0:02:42.320,0:02:49.120
technical depth they have. All this is written 
down in my book "Sustainable Software Architecture"

0:02:49.120,0:02:55.840
with many examples and pitfalls that one 
encounters on the way to a good architecture.

0:02:58.000,0:03:07.280
I have been working since 1999 at my 
company called WPS Workplace Solutions.

0:03:08.480,0:03:19.920
We started with 12 coders and today we have 130 coders 
in the company. We really love modular software

0:03:19.920,0:03:28.000
systems with a good architecture and we have been 
working with Domain-Driven design since 2004.

0:03:29.200,0:03:37.040
We are located in Germany in the middle 
of europe and we are sitting in Hamburg

0:03:37.040,0:03:43.040
and in Berlin as well Berlin is the capital 
of Germany as some of you might know.

0:03:44.800,0:03:52.320
We are building enjoyable business software 
this means um software that the user really

0:03:52.320,0:04:01.040
loves to work with like this one here you can 
see on the slide this is a software to coordinate

0:04:01.040,0:04:07.680
the construction works on the roads of different 
large towns. There are three towns

0:04:07.680,0:04:14.320
in Germany that are using this system today 
and one part of this system is a touch table

0:04:15.200,0:04:22.000
to make it possible that people from different 
organizations from towns, from water pipe companies,

0:04:22.000,0:04:27.840
from telecommunication companies that they meet 
and discuss their construction work together

0:04:28.960,0:04:35.600
and enjoyable business software from 
our point of view has a beautiful user interface

0:04:36.320,0:04:44.240
but also a good architecture since only a 
system with a good sustainable architecture

0:04:44.240,0:04:51.440
can as well offer a long life good user 
interface and good procedures.

0:04:54.320,0:05:01.200
If we want to have a sustainable 
architecture why do we want that well

0:05:01.200,0:05:08.960
we want that because we want our software to have 
a long useful life and thus pay off our investment

0:05:08.960,0:05:16.800
that we did in the beginning and from my point 
of view software will only pay off our investment

0:05:17.360,0:05:23.840
if we have the lowest possible 
maintenance cost and extension cost.

0:05:23.840,0:05:31.120
So, if it's easy to change the system if it's 
easy to extend the system then our investment

0:05:31.680,0:05:38.480
was a good one and we will have a system that 
lives for a long time and this is only possible if

0:05:39.120,0:05:45.360
the system has a sustainable architecture if 
it's easy to understand, easy to change and

0:05:45.360,0:05:51.840
easy to extend. This saves time and this saves 
money if we have an architecture like that.

0:05:55.040,0:06:04.000
This diagram illustrates our goal visually we 
want to be able to keep adding a similar number

0:06:04.000,0:06:12.800
of features to our system for a long time to come.
On the y-axis you see numbers

0:06:12.800,0:06:19.600
from 0 to 20. Those are the numbers of 
features that we can deliver per release and

0:06:19.600,0:06:27.440
we want to have a high constant number there. you 
can see it starts around 16 features per release

0:06:27.440,0:06:35.920
and if you follow the green path then you stay 
on the same level with the features that you

0:06:35.920,0:06:44.240
can deliver per release but complexity and 
technical depth often prevent us from doing

0:06:44.240,0:06:52.080
so and we end up with a sad norm down there the 
curve goes down and we are not able to deliver

0:06:53.440,0:06:58.640
many features anymore per release, which 
is really frustrating for the users

0:06:58.640,0:07:08.800
and as well for the development team of course. 
During and after my PhD we have analyzed a great

0:07:08.800,0:07:15.520
many systems of different ages, sizes and 
programming languages you can see various

0:07:15.520,0:07:21.200
programming languages here on this on 
the slide. In the middle of the slide,

0:07:22.240,0:07:29.360
there is a pie chart showing how many systems 
of which size we have analyzed. So if you look

0:07:29.360,0:07:37.680
at the light blue there is 120 in there so 
we were able to analyze 120 systems and the

0:07:37.680,0:07:45.040
size is annotated on the side. These systems had 
a size up to hundred thousand lines of code.

0:07:45.040,0:07:53.440
So quite small hundred thousand lines of code 
those are systems like apps on smartphones or

0:07:53.440,0:08:03.040
the first version of a software system. But out 
there are systems that are much larger you can

0:08:03.040,0:08:10.960
see on the the purple ones half a million lines 
of code we have looked at 150 systems of that size

0:08:11.600,0:08:18.720
and they are also out there a lot of systems 
even bigger 1 million 5 million 15 million 

0:08:19.680,0:08:28.960
so there are a lot of quite huge systems out there 
and many of these systems are developed in modern

0:08:28.960,0:08:37.040
programming languages like Java, C# and so 
on, but they frustrate their developers a lot.

0:08:37.040,0:08:44.640
Because they have accumulated technical depth and 
complexity over the years of their construction

0:08:45.680,0:08:55.200
and, unfortunately, some of them are micro service 
architectures. The great new architectural style

0:08:55.200,0:09:02.880
that was supposed to solve all our problems 
when we were told about it around 2012.

0:09:03.760,0:09:11.600
It used to be that people would call 
me and say: "Carola, we have a legacy system

0:09:12.240,0:09:19.200
and we need help. It's getting more and more 
expensive and slower and slower to maintain.

0:09:20.240,0:09:27.600
Can you help us break the system into 
microservices?" So this was the past.

0:09:28.400,0:09:35.200
Today, people call me and they say: "Ah, Carola, 
we have a microservice architecture and

0:09:35.200,0:09:41.920
maintenance is getting more and more 
expensive and slow. Uh, what have we done wrong?"

0:09:42.880,0:09:50.400
Yes, what is wrong? Well, with a lot of microservice 
architectures people have made the same mistake

0:09:51.360,0:09:54.480
the same mistakes they made with monoliths before.

0:09:57.120,0:10:05.680
I stole this diagram here from Simon Brown because 
it explains so well that what was forgotten.

0:10:06.400,0:10:16.000
On the y-axis you have modularity, and on the 
x-axis you have the number of deployment units.

0:10:16.000,0:10:23.760
So, on the left side the two systems have 
just one deployment unit on the right side you have

0:10:23.760,0:10:32.960
various or larger number of deployment units 
and if you follow the y-axis, those two systems on

0:10:32.960,0:10:40.640
the bottom have low modularity and the ones 
up there have high modularity. And what people

0:10:40.640,0:10:49.120
forgot was that a good architecture is actually 
about creating independent modules. Therefore,

0:10:50.640,0:10:55.760
a modular architecture is actually 
the opposite to a big ball of mud.

0:10:55.760,0:11:04.000
In a modular architecture independence of 
modules is is the top priority, so even if you

0:11:04.000,0:11:11.120
have just one deployment unit you should have 
a modular monolith, which is on the left side

0:11:11.840,0:11:19.120
on the top. If you don't do that, you will 
end up with a big ball of mud. Not modular,

0:11:19.120,0:11:25.760
and just one number of deployment units. This is 
the one monolithic big ball of mud down there.

0:11:26.720,0:11:32.640
No matter if you have a monolith 
or a great number of deployment units,

0:11:33.200,0:11:40.640
what is shown on the y-axis. If you don't have 
independent modules, you have a big ball of mud

0:11:40.640,0:11:49.600
as well in a distributed system, with a lot of 
deployment units, and that is much worse than a

0:11:49.600,0:11:57.200
monolithic big bowl of mud. If modularity is not 
your top priority, your system will probably look like this.

0:11:57.200,0:12:05.920
This diagram on the right side shows a 
class cycle this is a strongly connected components.

0:12:08.560,0:12:15.280
Each square is a class and these classes are 
connected with lines this is where they're used

0:12:15.840,0:12:23.200
each other and the different colors in the 
diagram show that they come from 10 different modules.

0:12:23.200,0:12:31.680
This system was developed 15 years ago, I 
mean it is in development since 15 years and today

0:12:31.680,0:12:39.040
and the whole system has 3 million lines 
of code, which means that this tangled

0:12:40.000,0:12:47.120
class cycle that has half a million lines 
of code takes a big part in the system.

0:12:48.240,0:12:55.520
30 developers have been working on this system 
for 15 years. If you change one class in this

0:12:55.520,0:13:01.200
cycle you have to check the whole cyclic 
structure to exclude possible side effects.

0:13:02.000,0:13:05.840
This greatly slows down 
maintenance and enhancement.

0:13:07.360,0:13:15.040
Another example even bigger 10 million lines of 
code developed in Java over the last 20 years.

0:13:15.680,0:13:21.680
When they started, nobody told them about 
modularity, monoliths and microservices.

0:13:22.480,0:13:29.600
This was in 2000. These ideas did not even 
exist at that time and you see the result

0:13:30.400,0:13:38.080
what you see there is 90 modules and they are 
strongly connected you see arcs on the left

0:13:38.080,0:13:44.640
side and on the right side. They all need each 
other this is as well a real big ball of mud

0:13:45.680,0:13:52.640
and of course for the team a whole lot of extra 
work for maintenance and enhancement. What has

0:13:52.640,0:14:01.280
happened here? Nobody has reduced or controlled the 
dependencies in these complex structures, and what

0:14:01.280,0:14:08.240
can we do to prevent prevent this in 
our micro service architectures, well,

0:14:09.360,0:14:16.320
we do have very old principles at hand to 
prevent the big ball of mud in our architecture

0:14:16.880,0:14:25.840
this is high cohesion and lose coupling. Within 
a module the classes or packages should work

0:14:25.840,0:14:32.800
together to fulfill one responsibility. This 
responsibility connects them strongly together

0:14:33.520,0:14:39.600
and creates high cohesion. Other responsibilities 
should be separated into their own module,

0:14:40.240,0:14:48.080
and outside of the module we want lose coupling 
which means actually low coupling. One module

0:14:48.080,0:14:55.520
doesn't need much from another module. A module 
should be complete from a domain point of view.

0:14:55.520,0:15:01.280
This is what Domain-Driven Design is talking 
about as well. From outside of the module,

0:15:01.840,0:15:08.800
only relevant features should be visible and 
accessible. Details of the implementation should

0:15:08.800,0:15:16.480
remain hidden, and this is why we call this 
information hiding. A good modular architecture

0:15:16.480,0:15:26.800
that follows these principles would look like this. 
We see here, three modules each of them should have

0:15:26.800,0:15:34.320
one responsibility and therefore have high 
cohesion within. The key point is that we should

0:15:34.320,0:15:41.440
build this architecture in such a way that we have 
as little coupling as possible between the modules.

0:15:42.080,0:15:52.320
But, but, this is only possible if there 
is an idea of a domain architecture.

0:15:52.880,0:15:59.520
Domain-Driven Design has given us the 
knowledge to create independent modules.

0:16:00.080,0:16:06.640
One module for the sales context as you 
can see here on the slide, and another one

0:16:06.640,0:16:14.480
for the support context. This is such a 
wonderful idea, and it works. It creates

0:16:14.480,0:16:23.120
modules that have high coercion and low coupling, 
which means dependency control. But unfortunately,

0:16:23.680,0:16:29.840
not many systems have a domain architecture. 
The other day, a client called me and said:

0:16:30.480,0:16:38.960
"Carola, we need help. We are having a micro service 
architecture." Woohoo yes! I thought inside of myself.

0:16:40.240,0:16:45.200
And he continued: "We are having a 
microservice architecture for our platform

0:16:45.200,0:16:52.800
where customers can sell their second-hand 
vehicles and we have 270 microservices."

0:16:53.760,0:17:00.960
Oh this is quite a lot I thought. "And what 
is the problem, well, if we want to change

0:17:00.960,0:17:10.560
something in the database. We have to discuss 
this with all teams." What? What does this mean?

0:17:11.280,0:17:19.600
Well we looked at the thing, and each 
microservice was using a library called "model-jar"

0:17:21.440,0:17:27.760
I ask them what this is, and they say: "Well, 
that's the interface to the database you know.

0:17:28.800,0:17:35.120
The one and only database." When the second 
microservice was built, they thought

0:17:35.120,0:17:39.840
that they could just reuse the work 
of the first team on the domain model.

0:17:40.400,0:17:48.480
So they took the "model-jar", enhanced it for their 
purpose and ended up with an overall domain model.

0:17:51.280,0:17:56.800
I have an example for you with a similar 
problem where we try to find a solution.

0:17:58.000,0:18:05.600
I will explain the diagram to you in a second 
but i will tell you the story before. A company

0:18:05.600,0:18:12.160
called us to look at their architecture 
and help them to divide it into microservices,

0:18:12.720,0:18:20.560
and I asked them. "Well, what kind of architecture 
do you have?" And normally people tell me: "We have a

0:18:20.560,0:18:29.600
layered architecture." But this one was different. 
They said: "Our architecture follows use cases."

0:18:31.360,0:18:38.960
This is a criterion from the domain and I 
thought finally no layered architecture 

0:18:38.960,0:18:43.280
this will be exciting. And what 
you see here on the slide

0:18:44.000,0:18:51.600
is the architecture that we put on the source 
code with a tool. This tool is called "Sotograph".

0:18:52.880,0:18:59.920
For each use case, we have created a rectangle 
and written the name of the use case next to it.

0:19:00.560,0:19:07.520
As you can see here, mailing, import 
export, remove, startup and so on.

0:19:08.720,0:19:14.720
The dependencies between the systems parts that 
are programmed into the source code as you know

0:19:15.280,0:19:24.400
are shown on the right side of the diagram. 
The green arcs go downwards, so they represent

0:19:24.400,0:19:31.600
relationships from top to bottom, so some class 
in the mailing use case is using something from

0:19:31.600,0:19:40.800
the import export use case. The red arcs colors 
are not important at the moment. The red arcs

0:19:40.800,0:19:48.400
represent relationships from bottom to top, so 
the remove use case there is a class in there

0:19:48.400,0:19:55.200
that needs something or that calls another 
class from the import export use case.

0:19:58.240,0:20:05.360
After collecting the use cases, we looked at 
the dependencies and we thought, well, maybe

0:20:05.360,0:20:08.640
mailing, import, export and remove. They could form

0:20:08.640,0:20:13.280
one microservice because they need each 
other of course and then there is a gap.

0:20:15.440,0:20:22.800
But, if you look downwards you find 
something which is quite strange, because,

0:20:23.600,0:20:30.960
down there, there is a part of the system called 
"model", and you guess it this is the equivalent

0:20:30.960,0:20:39.440
of the "model-jar", I told them, well, this is not 
a good idea if you wanted to cut your system into

0:20:39.440,0:20:48.640
microservices. We have to do something about 
this and so we tried to distribute the classes

0:20:48.640,0:20:56.320
that are in this "model-jar" to the other 
to the use cases so we took classes in here and

0:20:56.320,0:21:03.840
moved them upwards, some to the mailing, some to the 
import export, where they probably belong because

0:21:03.840,0:21:11.760
they belong to this part of the system
and they form the bases in there.

0:21:14.320,0:21:20.960
So, we started and i think we 
stopped when we put some classes

0:21:20.960,0:21:25.760
into your calculation because then 
the thing already looked like.

0:21:27.920,0:21:35.200
As you can see on the right side. We allocated 
model classes to the other to the use cases

0:21:35.200,0:21:45.120
and all these extra relationships dependencies 
appeared. They were all hidden in the model. So you

0:21:45.120,0:21:53.920
can see now that mailing is as well has as well 
connections to report and to editing many many

0:21:55.040,0:22:02.160
new dependencies they were all hidden, so what 
we can see here is another big ball of mud.

0:22:05.200,0:22:11.680
So please, if you are building, or 
having a micro service architecture.

0:22:11.680,0:22:19.440
Try to divide your domain into sub-domains with 
small models. Try to create separate models,

0:22:21.920,0:22:30.800
because then you will allow independent changes.
You will have high coercion and loose

0:22:30.800,0:22:37.360
coupling and your team can work independently. Your 
teams, the different teams for each microservices.

0:22:38.160,0:22:47.600
Because each model and each sub-domain should be 
small enough to be programmed by just one team.

0:22:47.600,0:22:56.240
Otherwise your team will feel like the chickens on 
the right side. These chickens have eaten pieces of

0:22:56.240,0:23:04.480
bread, but unfortunately some children have tied 
those bread pieces together with a rope, and

0:23:04.480,0:23:12.880
after swallowing them. The chickens are no longer 
independent and they might even die together, so,

0:23:12.880,0:23:21.440
let's look at a solution here. This is a banking 
example, a bank with three business areas.

0:23:21.440,0:23:31.200
Account Managing, Credit Business and Security Business. 
These three areas use the same classes: Account,

0:23:31.200,0:23:39.760
Customer, Credit and Security" to fulfill their 
work, so one big "model-jar" for the whole system.

0:23:41.040,0:23:47.440
If we want to break them down to the bottom 
of the domain model. We have to have much more

0:23:47.440,0:23:54.800
specific domain classes, "Account" and "Customer" 
are over here in the "Account Managing" and we

0:23:54.800,0:24:01.520
as well need "Credit Customer" and "Credit Account" 
as and "Security Account" and "Security Customer".

0:24:03.520,0:24:10.480
If you follow this advice, you will have separate 
models for all your modules and each team can work

0:24:10.480,0:24:19.440
freely on their own domain model. Doesn't that 
sound great? Yes. But how do we get there? Well,

0:24:19.440,0:24:27.840
we have to change our understanding of software 
development. In many organizations, that I have

0:24:27.840,0:24:34.480
visited. The responsibilities are clearly 
distributed. There's the role of the developers,

0:24:36.080,0:24:42.400
and the role of the architect is understood like 
this. Developer and architect are responsible for

0:24:42.400,0:24:50.160
technical questions. Their job is to define which 
programming language is used, which frameworks

0:24:50.160,0:24:57.040
and infrastructure is applied, which database to 
use. The domain knowledge is something that the

0:24:57.040,0:25:05.600
business analysts have to deal with, however. 
This division of responsibility will not work.

0:25:05.600,0:25:13.600
If we want our software to be structured according to 
domain related domain related criterias. To have a

0:25:13.600,0:25:20.240
domain related structure we have to make sure 
that the software has its roots in the domain.

0:25:22.080,0:25:32.320
And that the software is reflecting, a reflection 
of the domain. Because at the end, the source code

0:25:32.320,0:25:40.560
only contains the understanding of the developers. 
Not the requirements written down in the backlog

0:25:40.560,0:25:47.440
by the business analysts. The source code is 
the written down understanding that programmers

0:25:48.000,0:25:54.320
have of the domain, nothing else. That's exactly 
what Domain-Driven Design wants to help us with.

0:25:54.880,0:26:00.240
The goal of software development is to 
translate the domain knowledge into software.

0:26:01.520,0:26:08.400
To understand the domain properly, we have 
to talk to the domain experts. They have the

0:26:08.400,0:26:17.440
domain knowledge in their head. But, we have 
to do this in a language they understand.

0:26:19.840,0:26:26.000
If not we will suffer from the model 
monopoly. This is a well-described problem

0:26:26.000,0:26:31.920
in psychology. If you use a notation, that 
transports your understanding of something

0:26:31.920,0:26:41.040
to another person, and you use a notation that only 
you know. You will have a monopoly on the model.

0:26:42.480,0:26:50.080
A model like this for example, this is a, of course, 
an extreme example but the underlying message.

0:26:50.080,0:26:57.760
Of the model monopoly is, if you show a model to 
someone in a notation that is new for this person,

0:26:59.440,0:27:05.760
it is very difficult for the other person 
to understand this model. The notation you are

0:27:05.760,0:27:12.880
using for the model is a new language, that the 
user would have to learn to understand and

0:27:12.880,0:27:19.520
give feedback. This will result in a feedback 
like: "Oh, yeah this looks good, quite complicated.

0:27:19.520,0:27:26.560
I see you thought a lot about it." This is 
what users say in a case like that, and then you

0:27:26.560,0:27:35.040
end up with a software system that does not fit 
the needs of your user. How do we get to 

0:27:35.040,0:27:42.160
communicate with results that our users understand. 
What should we do? Well, Domain-Driven Design

0:27:42.720,0:27:50.480
recommends us to explore the domain together 
with users and developers in workshops. 

0:27:50.480,0:27:58.000
Two techniques have developed in recent years in the 
Domain-Driven Design environment: "Event Storming",

0:27:58.000,0:28:06.720
and "Domain Storytelling". These are both workshop 
techniques that facilitate collaborative modeling.

0:28:07.760,0:28:14.240
For an event storming session, we meet with the 
user and developers and model the process in

0:28:14.240,0:28:22.320
the domain with sticky notes on the wall. Each 
sticky note represent a domain event.

0:28:22.320,0:28:29.440
All particip participants are invited to stick 
notes, which are then discussed and sorted

0:28:29.440,0:28:36.240
with the whole group afterwards. This way, you get 
a quick overview of the process without thinking

0:28:36.240,0:28:43.840
about the software. Today, of course we are 
doing Event Storming remotely on a "Mirror" board.

0:28:45.760,0:28:52.400
In a session for Domain Storytelling, we also 
meet with the users and developers and model the

0:28:52.400,0:29:02.400
process from the domain with actors, who exchange 
domain objects and concepts. Today we also do this

0:29:02.400,0:29:09.120
remotely with an open source tool, called "Domain Story Modeler"
Let's look at this with an example.

0:29:11.200,0:29:19.760
This is a domain story for a small art house 
cinema. In this little program cinema, there is

0:29:19.760,0:29:29.440
the cinema manager and the ticket agent. Once a 
week, in this little cinema is issued a new weekly

0:29:29.440,0:29:37.520
schedule for the next week. The process starts 
in the upper left corner over here, when the

0:29:37.520,0:29:45.200
advertising agency sends the plan for the 
advertising bookings. Once the cinema manager has

0:29:45.200,0:29:52.800
received this plan, he starts working on the 
weekly schedule with his super great legacy system, cinesmall.

0:29:53.440,0:30:00.480
The small yellow flash on 
the icon of the weekly schedule indicates

0:30:00.480,0:30:08.720
that the cinesmall software is used here. Next, the 
cinema manager gets the plan for the possible film

0:30:08.720,0:30:15.760
shows from the film distributor, and he looks at 
the national wide number of visitors. He negotiates

0:30:15.760,0:30:22.800
with the film distributor which film he can get 
and finally he finalizes the weekly schedule.

0:30:23.760,0:30:30.960
Our legacy system, cinesmall, then generates 
auditorium plans and the ticket agent can start

0:30:31.520,0:30:39.200
selling tickets for the new scheduled film shows. 
The customer comes to the cinema and asks for

0:30:39.200,0:30:47.760
tickets for a certain film show. The ticket 
agent checks the auditorium plan to see if he

0:30:47.760,0:30:54.880
can find suitable seats in the auditorium for the 
desired film show, and and he then sells the

0:30:54.880,0:31:03.040
seats to the customer. This is very domain specific 
as you can see. You don't find any technical terms

0:31:03.040,0:31:11.280
in this domain story. This is because Domain-Driven 
Design asks us to be aware, that the users speak a

0:31:11.280,0:31:19.440
different language than we do, it's not good if 
we impose our technical language on them, that

0:31:19.440,0:31:26.160
would also be a kind of model monopoly, in which 
we use a model, that the user does not understand.

0:31:27.600,0:31:34.320
No, we have to immerse ourselves into the 
language of the domain experts and learn it.

0:31:35.520,0:31:42.720
Of course not everything, but only the part that 
we want to map in our software. The part in which

0:31:42.720,0:31:50.880
our software this system should support the 
users. And what happens then in the software?

0:31:50.880,0:31:54.800
Are we sticking to our 
technical terms in the software,

0:31:54.800,0:32:01.840
in the source code? No, we also use the 
domain specific terms in the source code.

0:32:03.600,0:32:11.200
Domain-Driven design calls this a ubiquitous 
language, a language that we use in all

0:32:11.200,0:32:21.040
communication if we speak, if we write, if we create 
diagrams and if we program in our source code.

0:32:23.440,0:32:30.080
Of course, the domain specific ubiquitous 
language is only used in the domain

0:32:30.080,0:32:37.200
core of the application. In the technical areas, we 
continue to use our technical programming language.

0:32:38.960,0:32:46.160
Sorry, okay. But now, we have a domain application 
core and I thought we want to have separate

0:32:46.160,0:32:50.000
domain models in the architecture with 
high cohesion and low coupling, right?

0:32:50.640,0:32:58.000
How do we get that to achieve this? Domain-Driven 
Design taught us the strategic design.

0:33:00.080,0:33:04.880
Our software system supports 
users in their work in a domain.

0:33:05.440,0:33:11.920
Domain-Driven Design tells us that in a domain, 
above a certain size there should be sub-domains,

0:33:13.440,0:33:17.760
that can help us to divide our 
software into bounded contexts.

0:33:20.560,0:33:28.880
Each bounded context sets explicit boundaries for 
individual domain oriented paths in the software.

0:33:29.440,0:33:36.480
And as well, in the team organization, each 
bounded context is handled by exactly one team.

0:33:37.120,0:33:43.600
We do all this, because our goal, 
you remember, is high cohesion and

0:33:43.600,0:33:50.560
lose coupling for our bounded context. Let's 
go back to the process in the cinema and see

0:33:50.560,0:33:58.880
what we can do there. You remember this, if you 
look closely at this process, you can see there

0:33:58.880,0:34:06.000
are actually two entries, that is two triggers 
that set different parts of the process in motion.

0:34:07.200,0:34:14.480
This is an important criterion that 
they could be two sub-domains in here.

0:34:14.480,0:34:20.960
You see the two triggers on the left and on 
the right. In addition, the two sub-processes

0:34:21.920,0:34:29.760
are also decoupled in terms of time. The left 
one is performed once a week the weekly schedule,

0:34:29.760,0:34:37.360
and the right one, whenever the customer 
comes to the cinema.

0:34:40.320,0:34:46.080
So in large cinemas there are 
also department for these two sub-process,

0:34:46.080,0:34:49.520
the cinema management and the ticket sales.

0:34:51.840,0:34:58.880
The next very important indicator in here is found 
in the middle, when the left sub-process is over,

0:34:58.880,0:35:06.160
there is a flow of information in one direction 
into the other sub-process. The flow of information

0:35:06.160,0:35:14.080
is the weekly schedule and then the process 
continues with the ticket sale. A way back is

0:35:14.080,0:35:24.000
not possible. This is a very very strong indicator 
of a boundary between two bounded contexts,

0:35:24.000,0:35:30.480
two sub-domains. The work in one sub-domain is done, 
and the result is passed on to another sub-domain.

0:35:31.200,0:35:38.000
In the second sub-domain, work is continued 
on the result, or with the result. Finally,

0:35:38.000,0:35:42.960
you can use this example to make another 
point from Domain-Driven Design clear.

0:35:43.600,0:35:50.240
Domain-Driven Design assumes that terms 
in different sub-domains can mean different things

0:35:50.240,0:35:57.360
and we can also imagine that here 
for our cinema. The customer looks at a

0:35:57.360,0:36:04.080
weekly schedule to find out about the planned 
film shows. This weekly schedule is much less

0:36:04.640,0:36:11.760
detailed than the weekly schedule that the 
cinema manager is working on. He notes the

0:36:11.760,0:36:16.480
cleaning time of the cinema halls and 
the ice cream sellers and much more.

0:36:20.800,0:36:27.680
So let's summarize. We can cut the domain 
into sub-domains according to boundaries in

0:36:27.680,0:36:35.120
the business processes. Good indicators are the 
information flow as you have seen the process

0:36:35.120,0:36:43.120
rhythms or the process triggers. We can cut the 
domain according to different uses of key concepts

0:36:43.120,0:36:48.400
in the domain or as well by departments 
in the organization or groups of experts.

0:36:49.040,0:36:53.440
So what does that mean for our architecture 
with the domain core and the technical

0:36:53.440,0:37:00.240
separated from the domain core? We get a domain 
core that is divided into domain modules with

0:37:00.240,0:37:06.800
separate domain models and separate domain and 
application services. What would a solution in

0:37:06.800,0:37:14.080
software look like for our cinema if we split it 
into two bounded contexts according to these rules?

0:37:14.880,0:37:20.320
In a good solution we would have two 
bounded contexts, Cinema Manager and

0:37:20.320,0:37:25.840
Ticket Sales. The bounded context Cinema 
Manager would provide a user interface

0:37:26.960,0:37:32.480
for scheduling the weekly schedule. 
This user interface works on a service

0:37:32.480,0:37:38.560
that allows you to schedule movies in theaters 
schedule advertising for movies and

0:37:38.560,0:37:44.960
much more. The service itself uses the weekly 
schedule and the auditorium plan to do its work.

0:37:45.600,0:37:53.200
The bounded context Ticket Sales would provide 
a user interface as well. But for the Ticket Sales,

0:37:53.200,0:38:01.600
it works on a service itself and this service 
uses the weekly schedule the auditorium plan

0:38:01.600,0:38:08.240
and the tickets of course to communicate with 
each other and the two bounded contexts

0:38:08.240,0:38:16.160
in exchange the weekly schedule and the auditorium 
plan. But this processing between the two bounded

0:38:16.160,0:38:23.760
contexts is done as in chronically. They don't 
depend on each other. They are loosely coupled.

0:38:23.760,0:38:32.720
A bad solution would be to divide the domain 
according to the entities involved in the process.

0:38:32.720,0:38:41.120
Here we will need direct coupling in 
this solution. In a solution that is bad, we

0:38:41.120,0:38:48.240
would have a "Service Weekly Schedule" and a "Service 
Auditorium Plan", one service for each entity.

0:38:48.240,0:38:55.360
Both entities would be protected by services and 
their interface, and the methods that are necessary

0:38:55.360,0:39:02.720
to process the respective entities. Because the 
methods are now each assigned to the service for

0:39:02.720,0:39:12.000
the entity at least the ticket sale user interface 
must work synchronously with both services.

0:39:12.000,0:39:18.560
In addition there must be another service 
for the tickets somewhere. Comparing these

0:39:19.840,0:39:27.200
these two solutions, we see loose 
coupled bounded contexts on

0:39:27.200,0:39:34.320
the left green side and strongly coupled system 
parts on the right side. Domain-Driven Design

0:39:34.320,0:39:42.960
recommends us, the left green side and strongly and 
not to do strongly coupled systems on the right side.

0:39:42.960,0:39:50.400
If you go the left green way, you have to 
live with the fact that you have the same entities

0:39:50.400,0:39:57.360
in different boundary compounded contexts. The 
weekly schedule is presented in both contexts.

0:39:58.080,0:40:04.080
You can see that and the auditorium 
plan as well. But what is with reuse then?

0:40:06.480,0:40:10.320
We have all learned in our software 
engineering courses that we

0:40:10.320,0:40:18.960
should do dry. Dry a principle don't repeat 
yourself and don't have duplicated code

0:40:19.520,0:40:27.440
and luckily enough. Domain-Driven Design speaks 
about this as well. Imagine you are building

0:40:27.440,0:40:35.120
a system for four different sub-domains. In the old 
times, companies have organized the work like this,

0:40:35.840,0:40:40.160
a head team, a team for the body, a team 
for the legs and a team for the tail.

0:40:40.960,0:40:47.520
Well, there were a lot of interfaces between 
these teams. They have to talk a lot and to

0:40:48.240,0:40:54.640
rely on each other to fulfill their jobs. You see 
all the the dependencies, all the errors there.

0:40:56.560,0:41:02.800
After a while, reuse starts to take place. 
This is almost inevitable the

0:41:02.800,0:41:08.720
body team finds out that there are things 
that all body teams need, and the lag team

0:41:08.720,0:41:13.680
puts together the yellow and 
the blue part, and the tails create

0:41:15.200,0:41:25.760
reusable systems as well. This is inevitable 
because what happens is, conway's law.

0:41:25.760,0:41:35.120
The team conway's law says, that organizations which 
are designing systems are constrained

0:41:35.120,0:41:42.000
to produce designs which are copies of the 
communication structures of their organization,

0:41:42.000,0:41:47.840
which means if a team is working on something. 
This something gets closer together, and then

0:41:49.680,0:41:56.960
reuse gets even further, because some developers 
change team and they start to use the framework

0:41:56.960,0:42:05.120
of the old team, and then we really have a big 
ball of mud. Domain-Driven Design says don't do this.

0:42:05.120,0:42:14.000
Go for domain excellence, not for reuse. Let 
teams build their own domain specific software

0:42:14.000,0:42:22.240
from UI to database. If we call up our 
model of our software again that means,

0:42:23.760,0:42:32.320
no reuse in the domain application source code. 
Here, each piece of software should be a specific

0:42:32.320,0:42:39.680
piece of software for its sub domains as 
specifically as possible. But in the technical

0:42:39.680,0:42:46.960
part of the system, there we should definitely 
do reuse, that's for sure, but not in the domain a

0:42:46.960,0:42:54.960
specific part. And finally I want to show you that 
it is possible to find out where you stand when

0:42:54.960,0:43:03.200
it comes to modularization within your system. If 
you want to know how modular your source code is.

0:43:03.200,0:43:10.080
Whether if it's microservices or monolith. We can 
measure this with the modularity maturity index.

0:43:10.640,0:43:20.720
If the modularity is poor. The system is rated 
zero to four. If the modularity is quite mediocre.

0:43:21.760,0:43:29.360
We give four to eight as great, and if the 
modularity is good the system gets 8 to 10.

0:43:31.120,0:43:37.760
The x-axis represents just the time and 
now I will show you some some systems.

0:43:39.600,0:43:47.920
You can see different cycles here, Each of which 
stands for one system, so these are 22 systems

0:43:47.920,0:43:54.400
in different programming languages. Some are 
in the red area, some in the yellow and some in

0:43:54.400,0:43:59.920
the green. And on the x-axis is just the time, this 
was the first system, this is the second and so on.

0:44:01.040,0:44:08.560
The system up here was built in Java and has 40 
million lines of code. It's very modular, very good.

0:44:08.560,0:44:16.960
This one, unfortunately, as well is Java, with a 
very bad modularization. This one is Java

0:44:16.960,0:44:24.800
as well, with some, but not enough modularization 
to arrive at the green area. This one is C#,

0:44:24.800,0:44:32.640
but this one up here is C#, too. So you can see, 
that the programming language has little influence

0:44:32.640,0:44:39.360
on the modularity unfortunately. There's as 
well PHP, TypeScript and PLSQL in there. 

0:44:39.360,0:44:46.960
As the developers and architects have to take 
care of the modularity ourself, how do we get to

0:44:46.960,0:44:53.600
this rating well. We meet with our clients and we 
analyze their system for modularity with various

0:44:53.600,0:45:01.680
tools. You can see here, the Sonagraph, TeamScale, 
Structure 101, the Sotograph and Lattix. All tools

0:45:01.680,0:45:07.920
that help us to find out about the modularity. 
There's a quite complex algorithm to calculate

0:45:07.920,0:45:16.080
the modularity maturity in text. Of course, since 
march 2020, our meetings are virtual as this one as well.

0:45:16.080,0:45:23.120
If you want to know more about Sustainable 
Software Architecture and Domain-Driven Design.

0:45:23.120,0:45:31.840
Contact me via twitter or email, look at my 
book and thank you very much for your attention.

0:45:41.200,0:45:47.600
Okay, thanks Carola for your visit and 
informational whole speech. I really

0:45:47.600,0:45:53.680
find your speech very enjoyable, yeah. 
Thank you mom, thank you. Yeah, yeah, and

0:45:53.680,0:46:00.240
now especially I love the metaphor of the tree. 
You so far should root in the domain and your

0:46:00.240,0:46:06.400
modularity matrix that's really fun, and 
really inspiring and thoughtful, yeah, okay.

0:46:08.480,0:46:14.800
Let me see if you have any questions, 
please, please post your question

0:46:14.800,0:46:21.680
on the Slido, and you can upload your question 
so that I can see the question better, okay.

0:46:22.560,0:46:32.080
So the first question is, okay this one. "How do you 
imply this kind of method on a starup company?"

0:46:32.080,0:46:38.960
You have any experience to share? 
Oh yeah, yeah, This is a perfect question, what it I understood

0:46:38.960,0:46:47.760
it rightly, it was about startup, was it? Yeah, Phone, no?
Yeah.
Okay it was about startup.

0:46:47.760,0:46:53.120
Because I can't see it on the screen at the 
moment, so this is why I asked, okay. 
Okay, startup.

0:46:54.560,0:47:02.240
Ah, startup I can see the word even your wonderful, 
your wonderful language, yeah, okay so.

0:47:04.320,0:47:13.200
If, I mean in my company we start, of course, as 
well new projects all the time, we create software

0:47:13.200,0:47:24.320
for our customers. And what I do is I get all 
my colleagues trained so that they know how to

0:47:24.320,0:47:32.160
create good architecture, so a startup should as 
well have well formed developers that 

0:47:32.160,0:47:40.480
construct the new software that program, you know. 
And then one thing that anybody today should do,

0:47:40.480,0:47:47.040
whatever software you write, you have to do test 
first, or at least you have to write unit tests.

0:47:47.040,0:47:53.280
You know, maybe not before, but you have to write 
them, and if your software is full of unit tests.

0:47:53.280,0:47:58.400
There's a high percentage of source code 
tested with unit tests. Your architecture

0:47:58.400,0:48:04.720
will be better. This is an overall experience 
that I made, whenever I looked at any software.

0:48:04.720,0:48:10.640
Because if you want to test something, you start 
to create separate pieces, you know.

0:48:10.640,0:48:16.640
You can't have a tangled structure. This 
is very difficult to test, so please, please.

0:48:16.640,0:48:24.080
Startups do tests, do unit tests and this will help 
a lot, and then read books learn about modularity.

0:48:24.720,0:48:29.920
And your your software will live a long 
time, so I hope this is a good help for the startup.

0:48:29.920,0:48:36.960
Yeah, test first.
Yes, thank you.
Sometimes, you know, you have to create something, 

0:48:36.960,0:48:42.960
before you do the test, but test first is the best. 
Read books, exactly, they all write it down in the chat.

0:48:43.520,0:48:49.600
Yeah, I totally agree. I think some good 
practice applies everywhere, no better than a big

0:48:49.600,0:48:55.600
company or in the startup. Okay, I think we have 
still have time for maybe two questions, so next

0:48:55.600,0:49:04.560
one, someone from anonymous, okay. She's very, he 
or she is very curious about whether we can apply

0:49:04.560,0:49:11.360
DDD in agile. how to combine these two things to 
build a more sustainable software? Could you share

0:49:11.360,0:49:20.480
some insights? 
Yes, yes, my company is working agile 
since the beginning, and agile actually fits very

0:49:20.480,0:49:28.320
very well with Domain-Driven Design, because 
if you do agile, you have continuous

0:49:28.320,0:49:34.560
contact with your users. You after every 
iteration, you represent what you've done,

0:49:34.560,0:49:39.520
and you discuss what what you can do next. And 
this is actually what Domain-Driven Design wants.

0:49:39.520,0:49:46.480
Domain-Driven Design wants that we have a lot of 
contact with our users that we discuss with them,

0:49:46.480,0:49:52.720
so that the developers get better into the 
domain, understand more about the domain.

0:49:52.720,0:49:58.720
So these two ideas fit perfectly with each other. 
There's no problem there, I can see no problem.

0:50:00.720,0:50:05.520
Yes that's a good news, yeah I think there's lots 
of people, because lots of people in taiwan knows

0:50:05.520,0:50:13.600
about agile, so maybe it's a good starting point for them to access DDD.
Yes, yes.
Okay, I think we still have

0:50:13.600,0:50:22.240
time for the final question. The final question 
is: "When transforming legacy system to microservice,

0:50:22.240,0:50:30.320
we find problems like how to break the monolith 
into parts and keep the data consistency.", yeah.

0:50:30.320,0:50:36.160
Do you have any suggestion about this, about 
how to do the migration or any tips? 

0:50:36.160,0:50:42.800
Yeah, very good question, yes. It's a big problem 
because you have to cut the thing as I showed you

0:50:42.800,0:50:49.120
on the slide, as well, down to the database and you 
have to separate the database into different parts.

0:50:49.120,0:50:56.800
So you will have one database per microservice, 
and of course this is scary in the beginning.

0:50:56.800,0:51:02.560
Because you think, oh my god I have a customer 
here, and I mean you have seen it on my diagram, the

0:51:02.560,0:51:08.000
customer in the account management, the customer 
in the credit and it's always the same person.

0:51:08.000,0:51:15.280
What does this mean, well, actually it's not such 
a problem, because each bounded context works on a

0:51:15.280,0:51:22.560
part of the customer, that the other one is not 
working on. And you can transport the data

0:51:22.560,0:51:32.880
from one database microservice to the other by 
events and by what do you say,

0:51:32.880,0:51:39.520
by distributing the data from one microservice to 
microservice. And actually, this is something

0:51:39.520,0:51:46.960
we do in huge companies anyway. We have a lot 
of systems there and we always transport the

0:51:46.960,0:51:53.680
data about the customer from one system to the 
other, so it's not such a scary thing. Of course,

0:51:53.680,0:51:58.880
you have to keep them consistent, and that's 
sometimes it takes time to get all the systems

0:51:58.880,0:52:06.400
in sync. But you know, with Amazon, Netflix and all 
those companies, there is no need to be consistent

0:52:07.280,0:52:13.040
everywhere in the same moment. You can have 
some delay. It's not a real problem in general.

0:52:15.760,0:52:22.000
Okay, thank you very, very insightful. Yeah, and 
they also raise my bills about your speech

0:52:22.000,0:52:27.280
talking about, sometimes maybe you should forget 
about the micro service, maybe you should consider

0:52:27.280,0:52:35.360
more about your modularity and the context.
Yes. 
Yeah, cool. Absolutely, thank you again. Yeah, thank

0:52:35.360,0:52:41.600
you again very much.
It was a pleasure.
And we are very honor to have you here, yeah, thank you, yeah.

0:52:41.600,0:52:47.280
Okay, so the session ends here. If you have any more 
questions or if you want to have a talk with Carola,

0:52:47.280,0:52:53.760
you can go to the private room with her 
and you can have a good talk. So thank you Carola again,

0:52:53.760,0:53:04.160
and the next session will start at 4:30, yeah. 
Okay, 4:30. So the next speaker will be Luca.

0:53:04.160,0:53:13.520
So okay, see you, see you everyone, goodbye. 
Bye bye! Thank you, thank you everyone.
Thank you.
