experiences from 15 years of the management design okay so you can scan the qr code on the on the top right and you can go to slider and ask some questions so let's welcome dr carola hello good morning phone good morning i mean good morning from europe you know we have morning here yeah it's afternoon here yeah perfect

should i start um sharing my slides sure okay so current can can you try showing your site yes sure here we go

can you see them yes very good perfect you can start your speech thank you thank you thank you very much hi everybody um in this talk i will show you how to build systems in a way that makes sense for the business and um how the main driven design can help you to do that um my name is carola and on twitter you can find me under my handle cairoli i have studied computer science at the university of hamburg and i gained my diploma in 1995 and since then i have done a lot of programming in c plus plus in java even in visual basic and in c-sharp of course as well and i have done a lot of consulting taking planes to visit my customers and i work as an architect and architectin this is the german female version of an architect and in 2008 i handed in my phd thesis with the title complexity of software architecture i then turned um all the things i found out in my doctor's thesis into a business model for my company um we evaluate the complexity of software architectures and check whether they are sustainable and how many technical depth they have all this is written down in my book sustainable software architecture with many examples and pitfalls that one encounters on the way to a good architecture

i have been working since 1999 at my company called wps workplace solutions we started with 12 coders and today we 130 coders in the company we really love modular software systems with a good architecture and we have been working with domain driven design since 200 2004. we are located in germany in the middle of europe and we are sitting in hamburg and in berlin as well berlin is the capital of germany as some of you might know we are building enjoyable business software this means um software that the user really loves to work with um like this one here you can see on the slide this is a software to coordinate the construction works on the roads of different different large towns um there are three towns in germany that are using this system today and one part of this system is a touch table to make it possible that people from different organizations from towns from water pipe companies from telecommunication companies that they meet and discuss their construction work together and uh enjoyable business software from from our point of view has a beautiful user interface but also a good architecture since only a system with a good sustainable architecture can as well offer a long life good user interface and good good procedures um

if we if if we want to have um a sustainable architecture why do we why do we want that well we want that because we want our software to have a long useful life and thus pay off our investment that we did in the beginning and from my point of view software will only pay off our investment if we have the lowest possible maintenance cost and extension cost so if if it's easy to change the system if it's easy to extend the system then our investment was a good one and we will have a system that lives for a long time and this is only possible if the system has a sustainable architecture if it's easy to understand easy to change and easy to extend this saves time and this saves money if we have an architecture like that

this diagram illustrates our goal visually we want to be able to keep adding a similar number of features to our system for a long time to come um on the on the um y-axis you you see um numbers from 0 to 20 though those are the numbers of features that we can deliver per release and we want to have a high constant number there you can see it starts around 16 features per release and if you follow the green path then you stay on the same level with the features that you um can deliver per release um but complexity and technical depth um often prevent us from doing so and we end up with a sad norm down there the curve goes down and we are not able to deliver many features anymore per release which is really frustrating for the users and as well for the development team of course during and after my phd we have analyzed a great many systems of different ages sizes and programming languages you can see various programming languages here on this on the slide in the middle of the slide there is a pie chart showing how many systems of which size we have analyzed so if you look at the light blue um there is 120 in there so we were able to analyze 120 systems and the size is annotated on the side these systems had a had a size up to um hundred thousand lines of code so quite small hundred thousand lines of code um those are systems like apps on smartphones or the first version of of a software system but out there are systems that are much larger um you can see um the the purple ones half a million lines of code we have looked at 150 systems of that size and they are also out there a lot of systems even bigger 1 million 5 million 15 million um so there are a lot of quite huge systems out there and many of these systems are developed in modern programming languages like java c-sharp and so on but they frustrate their developers a lot because they have accumulated technical depth and complexity over the years of their construction and unfortunately some of them are micro service architectures the great new architectural style that was supposed to solve all our problems when we were told about it around 2012. um it used to be that people would call me and say carola we have a legacy system and we need help it's getting more and more expensive and slower and slower to maintain can you help us break the system into into microservices so this was the past today people call me and they say ah corolla we have a microservice architecture and maintenance is getting more and more expensive and slow uh what have we done wrong yes what is wrong well with a lot of microservice architectures people have made the same mistake the same mistakes they made with monoliths before

i stole this diagram here from simon brown because it explains so well what that what was forgotten on the y-axis you have modularity and on the on the um x-axis you have the number of deployment units so on the left side the two systems have just one deployment unit on the right side you have various or larger number of deployment units and if you follow the y-axis those two systems on the bottom have low modularity and the ones up there have high modularity and what people forgot was that a good architecture is actually about creating independent modules therefore a modular architecture is actually the opposite to a big ball of mud in a modular architecture independence of modules is is the top priority so even if you have just one deployment unit you should have a modular monolith which is on the left side on the top if you don't do that you will end up with a big ball of mud not modular and just one number of deployment units this is the one monolithic big ball of mud down there um no matter if you have a monolith or a great number of deployment units what is shown on the y-axis if you don't have independent modules you have a big ball of mud as well in a distributed system with a lot of deployment units and that is much worse than a monolithic big bowl of mud if modularity is not your top priority your system will probably look like this this diagram on the right side shows a class cycle this is a strongly connected component

each square is a class and these classes are connected with lines this is where they're huge each other and the different colors um in the diagram show that they come from 10 different modules this system was developed 15 years ago i mean it is in development since 15 years and today and the whole system has 3 million lines of code which means that this this tangled class cycle that has half a million lines of code takes a big part in the system 30 developers have been working on this system for 15 years if you change one class in this cycle you have to check the whole cyclic structure to exclude possible side effects this greatly slows down maintenance and enhancement another example even bigger 10 million lines of code developed in java over the last 20 years when they started nobody told them about modularity monoliths and microservices this was in 2000 these ideas did not even exist at that time and you see the result what you see there is 90 modules and they are strongly connected you see arcs on the left side and on the right side they all need each other this is as well a real big ball of mud and of course for the team a whole lot of extra work for maintenance and enhancement what has happened here nobody has reduced or controlled the dependencies in these complex structures and what can we do to prevent prevent this in our micro service architectures well um we do have very old principles at hand to prevent the big ball of mud in our architecture this is high cohesion and lose coupling within a module the classes or packages should work together to fulfill one responsibility this responsibility connects them strongly together and creates high cohesion other responsibilities should be separated into their own module and outside of the module we won't lose coupling which means actually low coupling one module doesn't need much from another module a module should be complete from a domain point of view this is what domain driven design is talking about as well from outside of the module only relevant features should be visible and accessible details of the implementation should remain hidden and this is why we call this information hiding a good modular architecture that follows these principles would look like this we see here three modules each of them should have one responsibility and therefore have high cohesion within the key point is that we should build this architecture in such a way that we have as little coupling as possible between the modules but but this is only possible if there is an idea of a domain architecture the main driven design has given us the the mod the knowledge to create independent modules one module for the sales context as you can see here on the slide and another one for the support context this is such a wonderful idea and it works it creates modules that have high coercion and low coupling which means dependency control but unfortunately not many systems have a domain architecture the other day a client called me and said karola we need help we are having a micro service architecture woohoo yes i thought inside of myself and he continued we are having a microservice architecture for our platform where customers can sell their second-hand vehicles and we have 270 microservices oh this is quite a lot i thought and what is the problem well if we want to change something in the database we have to discuss this with all teams what what does this mean well we looked at the thing and each microservice was using a library called model jar i ask them what this is and they say well that's the interface to the database you know the one and only database when the second microservice was built they thought that they could just reuse the work of the first team on the domain model so they took the model jar enhanced it for their purpose and ended up with an overall domain model

i have an example for you with a similar problem where we try to find a solution i will explain the diagram to you in a second but i will tell you the story before um a company called called us to look at their architecture and help them to divide it into microservices and i asked them well what kind of architecture do you have and normally people tell me we have a layered architecture but this one was different they said our architecture follows use cases this is a criterion from the domain and i thought finally no layered architecture this will be exciting and what you see here on the slide is the architecture that we put on the source code with a tool this tool is called sotograph for each use case we have created a rectangle and written the name of the use case next to it as you can see here mailing import export remove startup and so on the dependencies between the systems parts that are programmed into the source code as you know are shown on the right side of the diagram the green arcs go downwards so they represent relationships from top to bottom so some class in the mailing use case is using something from the import export use case the red arcs colors are not important at the moment the red arcs represent relationships from bottom to top so the remove use case there is a class in there that needs something or that calls another class from the import export use case

after collecting the use cases we looked at the the dependencies and we thought well maybe mailing import export and remove they could form one microservice because they need each other of course and then there is a gap

but um if you look downwards you find something which is quite strange because down there there is a part of the system called model and you guess it this is the equivalent of the model jar um i told them well this is not a good idea if you wanted to cut your system into microservices um we have to do something about this and so we tried to distribute the classes that are in this model jar um two to the other to the use cases so we took classes in here and moved them upwards some to the mailing some to the import export where they probably belong because they um belong to this um part of the of the of the system um and they form the bases in there um

so um we started and i think we stopped when we put some classes into your calculation because then um the thing already looked like that

as you can see on the right side we allocated model classes to the other to the use cases and all these extra um relationships dependencies appeared they were all hidden in the model so you can see now that mailing is as well has as well connections to report and to editing many many new new dependencies they were all hidden so what we can see here is another big ball of mud

so please if you are building or having a micro service architecture try to divide your domain into subdomains with small models try to create separate models

because then you will allow independent changes um you will have high coercion and low loose coupling and your team can work independently your teams the different teams for each microservices because each model and each sub-domain should be small enough to be programmed by just one team otherwise your team will feel like the chickens on the right side these chickens have eaten pieces of bread but unfortunately some children have tied those bread pieces together with a rope and after swallowing them the chickens are no longer independent and they might even die together so let's look at a solution here this is a banking example a bank with three business areas account managing credit business and security business these three areas use the same classes account customer credit and security to fulfill their work so one big model jar for the whole system if we want to break them down to the bottom of the domain model we have to have much more specific domain classes account and customer are over here in the account managing and we as well need credit customer and credit account as and security account and security customer if you follow this advice you will have separate models for all your modules and each team can work freely on their own domain model doesn't that sound great yes but how do we get there well we have to change our understanding of software development in many organizations that i have visited the responsibilities are clearly distributed there's the role of the developers and the role of the architect is understood like this developer and architect are responsible for technical questions their job is to define which programming language is used which frameworks and infrastructure is applied which database to use the domain knowledge is something that the business analysts have to deal with with however this division of responsibility will not work if we want our software to be structured according to domain related domain related criterias to have a domain related structure we have to make sure that the software has its roots in the domain and that the software is reflecting a reflection of the domain because at the end the source code only contains the understanding of the developers not the requirements written down in the backlog by the business analysts the source code is the written down understanding that programmers have of the domain nothing else that's exactly what domain driven design wants to help us with the goal of software development is to translate the domain knowledge into software to understand the domain properly we have to talk to the domain experts they have the domain knowledge in their head but we have to do this in a language they understand

if not we will suffer from the model monopoly this is a well-described problem in psychology if you use a notation that transports your understanding of something to another person and you use a notation that only you know you will have a monopoly on the model a model like this for example this is a of course an extreme example but the underlying message of the model monopoly is if you show a model to someone in a notation that is new for this person um it is very difficult for the other person to understand this model the notation you are using for the model is a new language that the user would have to learn to understand and keep give feedback this will result in a feedback like oh yeah this looks good quite complicated i i see you thought a lot about it this is what users say in a case like that and then you end up with a software system that does not fit the needs of your user how do we get to communi communicate with results that our users understand what should we do well domain driven design recommends us to explore the domain together with users and developers in workshops two techniques have developed in recent years in the domain driven design environment event storming and domain storytelling these are both workshop techniques that facilitate collaborative modeling for an event storming session we meet with the user and developers and model the process in the domain with sticky notes on the wall each sticky no note represent a domain event all particip participants are invited to stick notes which are then discussed and sorted with the whole group afterwards this way you get a quick overview of the process without thinking about the software today today of course we are doing event storming remotely on a mirror board in a session for domain storytelling we also meet with the users and developers and model the process from the domain with actors who exchange domain objects and concepts today we also do this remotely with an open source tool called the main story modeler let's look at this with an example

this is a domain story for a small art house cinema in this little program cinema there is the cinnabar manager and the ticket agent once a week in this little cinema is issued a new weekly schedule for the next week the process starts in the upper left corner over here when the advertising agency sends the plan for the advertising bookings once the cinema manager has received this plan he starts working on the weekly schedule with his super great legacy system sin is small the small yellow flash on the icon of the weekly schedule indicates that the cinesmall software is used here next the cinema manager gets the plan for the possible film shows from the film distributor and he looks at the national wide number of visitors he negotiates with the film distributor which film he can get and finally he finalizes the weekly schedule our legacy system cinesmall then generates auditorium plans and the ticket agent can start selling tickets for the new scheduled film shows the customer comes to the cinema and asks for tickets for a certain film show this the ticket agent checks the auditorium plan to see if he can find suitable seats in the auditorium for the desired film show and this and he then sells the seats to the customer this is very domain specific as you can see you don't find any technical terms in this domain story this is because domain driven design asks us to be aware that the users speak a different language than we do it's not good if we impose our technical language on them that would also be a kind of model monopoly in which we use a model that the user does not understand no we have to immerse ourselves into the language of the domain experts and learn it of course not everything but only the part that we want to map in our software the part in which our software this system should support the users and what happens then in the software are we sticking to our technical terms in the software in the source code no we also use the domain specific terms in the source code domain-driven design calls this a ubiquitous language a language that we use in all communication if we speak if we write if we create diagrams and if we program in our source code

of course the domain specific ubiquit ubiquitous language is only used in the domain core of the application in the technical areas we continue to use our technical programming language sorry okay but now we have a domain application core and i thought we want to have separate domain models in the architecture with high cohesion and low coupling right how do we get that to achieve this domain driven design taught us the strategic design

our software system supports users in their work in a domain the main drum design tells us that in a domain above a certain size there should be sub domains that can help us to divide our software into bounded contexts

each bounded context sets explicit boundaries for individual domain oriented paths in the software and as well in the team organization each bounded context is handled by exactly one team we do all this because our goal you remember is high cohesion and lose coupling for our bounded context let's go back to the process in the cinema and see what we can do there you remember this if you look closely at this process you can see there are actually two entries that is two triggers that set different parts of the process in motion this is impo in an important criterion that they could be two subdomains in the in here you see the two triggers on the left and on the right in addition the two sub-processes are also decoupled in terms of time the left one is performed once a week the weekly schedule and the right one um whenever the customer comes to the to the um to the cinema

so um in large com cinemas there are also department for these two sub processes the cinnabar management and the ticket sales

the next very important indicator in here is found in the middle when the left sub process is over there is a flow of information in one direction into the other sub-process the flow of information is the weekly schedule and then the process continues with the ticket sale a way back is not possible this is a very very strong indicator of of of a boundary between two bounded contexts two subdomains the work in one subdomain is done and the result is passed on to another sub domain in the second sub domain work is continued on the real result or with the result finally you can do use this example to make another point from domain driven design clear the main driven design assumes that terms in different subdomains can mean different different things and we can also imagine that here for our cinema the customer looks at a weekly schedule to find out about the planned film shows this weekly schedule is much less detailed than the weekly schedule that the cinema manager is working on he notes the cleaning time of the cinema halls and the ice cream sellers and much more

so let's summarize we can cut the domain into sub-domains according to boundaries in the business processes good indicators are the information flow as you have seen the process rhythms or the process triggers we can cut the domain according to different uses of key concepts in the domain or as well by departments in the organization or groups of experts so what does that mean for our architecture with the domain core and the technical separated from the domain core we get a domain call that is divided into domain modules with separate domain models and separate domain and application services what would a solution in software look like for our cinema if we split it into two bounded contexts according to these rules in a good solution we would have two bounded contexts cinema manager and ticket sales the bounded context cinema manager would provide a user interface for scheduling the weekly schedule this user interface works on a service that allows you to schedule movies in theaters schedule advertise advertising for movies and much more the service itself uses the weekly schedule and the auditorium plan to do its work the bounded context ticket sales pro would provide a user interface as well but for the ticket sales it works on a service itself and this service uses the weekly schedule the auditorium plan and the tickets of course to communicate which with each other and the two bounded contexts in exchange the weekly schedule and the auditorium plan but this processing between the two bounded contexts is done as in chronically they don't depend on each other they are loosely coupled a bad solution would be to divide the domain according to the entities involved in the process here we we will we will need direct coupling in this solution in a solution um that is bad we would have a service weekly schedule and a service auditorium plan one service for each entity both entities would be protected by services and their interface and the methods that are necessary to process the respective entities because the methods are now each assigned to the service for the entity at least the ticket sale user interface much must work synchronously with both services in addition there must be another service for the tickets somewhere comparing these um comparing these two solutions we see loose coupling loose coupled bounded contexts on the left green side and strongly coupled system parts on the right side the main driven design recommends us the left green side and strongly and not to do strongly coupled systems on the right side if you go the left green way you have to live with the fact that you have the same entities in different boundary compounded contexts the weekly schedule is presented in both contexts you can see that and the auditorium plan as well but what is with reuse then

we have all learned in our software engineering courses that we should do dry dry a principle don't repeat yourself and don't have duplicated code and luckily enough domain driven design about speaks about this as well imagine you are building a system for four different sub-domains in the old times companies have organized the work like this a head team a team for the body a team for the legs and a team for the tail well there were a lot of interfaces between these teams they have to talk a lot and to re rely on each other to fulfill their jobs you see all the the dependencies all the errors there after a while reuse starts to take place this is almost inevitable inevitable the body team finds out that there are things that all body teams need and the lag team puts together the the yellow and the blue part and the tails create reusable systems as well this is inevitable because what happens is um conway's law the team conway's law says um that organizations with design which are designing systems are constrained to produce um designs which are copies of the communication structures of their organization which means if a team is working on something this something gets closer together and then reuse gets even further because some developers change team and they start to use the framework of of the old team and then we really have a big ball of mud domain driven design says don't do this go for domain excellence not for reuse let teams build their own domain specific software from ui to database if we call up our model of our software again that means no reuse in the domain application source code here each piece of software should be a specific piece of software for for its sub domains as specifically as possible but in the technical part of the system there we should definitely do reuse that's for sure but not in the domain a specific part and finally i want to show you that it is possible to find out where you stand when it comes to modularization within your system if you want to know how modular your source code is whether if it's microservices or monolith we can measure this with the modularity maturity index if the modularity is poor the system is rated zero to four if the modularity is quite mediocre we give four to eight as great and if the modularity is good the system gets 8 to 10. um the x-axis represents just the time and now i will show you some some systems you can see different cycles here each of which stands for one system so these are 22 systems in different programming languages some are in the red area some in the yellow and some in the green and on the x-axis is just the time this was the first system this is the second and so on the system up here was built in java and has 40 million lines of code it's very modular very good this one unfortunately as well is java with a very bad motor modularization this one is java as well with some but not enough modularization to arrive at the green area this one is c sharp but this one up here is c sharp two so you can see that the programming language has little influence on the modularity unfortunately there's as well php typescript and and plsql in there us the developers and architects have to take care of the modularity ourself how do we get to this rating well we meet with our clients and we analyze their system for modularity with various tools you can see here the sonagraph team scale structure 101 the psotograph and lattice all tools that help us to find out about the modularity there's a quite complex algorithm to calculate the modularity maturity in text of course since march 2020 our meetings are virtual as this one as well if you want to know more about sustainable software architecture and domain driven design contact me via twitter or email look at my book and thank you very much for your attention

okay thanks karola for your visit and informational whole speech i really find your speech very enjoyable yeah thank you mom thank you yeah yeah and now especially i love the metaphor of the tree your sofia should root in the domain and your modularity matrix that's really fun and really inspiring and thoughtful yeah okay

let me see if you have any questions please please post your question on the slider and you can upload your question so that i can see the question um better okay so the first question is okay this one how do you imply this kind of method on a star of company you have any experience to share oh yeah yeah this is a perfect question it's what it i understood it rightly it was about startup was it yeah no yeah yeah okay okay it was about startup no because i can't see it on the screen at the moment so this is why i asked okay okay stop stop ah startup i can see the word even your wonderful your wonderful language yeah okay so um um

um if i i mean in my company we start of course as well new projects all the time we create software for our customers and um what i do is i i get all my colleagues trained so that they know how to to create good architecture so a startup should as well have um well uh formed developers that that construct the new software that program you know and then um one thing that anybody today should do whatever software you write you have to do test first or at least you have to write unit tests you know maybe not before but you have to write them and if your software is full of unit tests there's a high percentage of source code tested with unit tests your architecture will be better this is an overall experience that i made whenever i looked at any software because if you want to test something you start to create um separate pieces you know you have you can't have a tangled structure this is very difficult to test so please please startups do tests do unit tests and this will help a lot and then read books learn about modularity and your your software will live a long time so i hope this is a good help for the startup um yeah test first yes sometimes you know you have to create something because you do before you do the test but test first is the best read books exactly they all write it down in the chat yeah yeah i totally agree i think some some good practice applies everywhere no better than a big company or in the startup okay i think we have still have time for maybe two questions so next one uh someone from anonymous okay she's very he or she is very curious about whether we can apply ddd in agile how to combine these two things to build a more sustainable software and you share some insights yes yes my company is working agile since the beginning and agile actually fits very very very well with domain driven design because um if you do actually agile you have um continuous contact with your users you after every iteration you represent what you've done and you discuss what what you can do next and this is actually what domain driven design wants the main driven design wants that we have a lot of contact with our users that we discuss with them so that the developers get better into the domain understand more about the domain so these two ideas fit perfectly with each other there's no problem there i can see no problem yes that's a good news yeah i think there's lots of people because lots of people in taiwan knows about asia so maybe it's a good starting point for them to access yes okay i think we still have time for for the final question the final question is when transforming legacy system to microservice we find problems like how to break the monolith into parts and keep the data uh consistency yeah do you have any suggestion about this about how to do the migration or any kicks yeah very good question yes it's a it's a big problem because you have to cut the thing as i showed you on the slide as well down to the database and you have to separate the database into different parts so you will have one database per microservice and of course this is scary in the beginning because you think oh my god i have the customer here and i mean you have seen it on my diagram the customer in the account management the customer in the credit and it's always the same person what does this mean well um actually it's not such a problem because each bounded context works on a part of the customer that the other one is not working on and um you can transport the data from one database microservice to the other um by events and by um by what do you say by distributed distributing the data from one microservice to microservice and actually this is somewhat thing we do in huge companies anyway we have a lot of systems there and we always transport the data about the customer from one system to the other so it's not such a scary thing of course you have to keep them consistent and that's sometimes it takes time to get all the systems in sync but you know with amazon netflix and all those companies there is no need to be consistent everywhere in the same moment you can have some delay it's not a real problem in general

okay thank you very very insightful yeah and they also rinse my bills about your speech talking about sometimes maybe you should forget about the micro service maybe you should consider more about your modularity and the context yeah yes cool absolutely thank you again yeah thank you again very much and we are very pleased to have you here yeah thank you yeah uh okay so the session ends here if you have any more questions or if you want to have a talk with corolla you can go to the private room with her and you can have a good talk so thank you corona again and the next session will start at 4 4 4 30 yeah uh well okay 4 30. so the next speaker will be lucas so okay see you see you everyone goodbye bye bye thank you thank you everyone thank you