0:00:00.280,0:00:10.080
Luca will  bring us the next speech

0:00:10.080,0:00:13.740
developing evolutionary AWS Lambda with Hexagonal
Architecture

0:00:13.740,0:00:19.990
Luca is AWS principle software solution
architect and a writer of O'Reilly

0:00:19.990,0:00:21.870
Also a very experienced international speaker
Then welcome Luca

0:00:21.870,0:00:43.749
Hello. Nice to meet you. Likewise. Now it's
your time so you can start at any time Perfect

0:00:43.749,0:00:50.449
fantastic thank you very much for the introduction
and sorry a bit for my voice I have a bit

0:00:50.449,0:00:55.940
of code so it would be a bit weird my voice
but don't worry I will do my best that you

0:00:55.940,0:01:02.239
will be able to enjoy the talk.
So today I'm going to talk about AWS Lambda

0:01:02.239,0:01:10.350
but specifically how to modularize your code
to have a let's say a system that would be

0:01:10.350,0:01:17.640
able to follow the drifts that the business
would it is looking for. Because in reality

0:01:17.640,0:01:23.710
every business is evolving and is changing
direction and we have some ways as architects

0:01:23.710,0:01:30.650
and developers that will allow us to follow
their direction and improve and evolve our

0:01:30.650,0:01:37.609
architecture following the right business
direction. My name is Luca Mezzalira I'm a

0:01:37.609,0:01:44.060
principal solution architect at AWS. I'm an
international speaker and an O'Reilly author.

0:01:44.060,0:01:50.350
So let's start with defining what evolutionary
architectures are and directly from the book

0:01:50.350,0:01:55.079
building evolutionary architecture that if
you didn't read. Trust me is a really great

0:01:55.079,0:01:56.859
book

0:01:56.859,0:02:01.369
You can see that evolution architecture supports
guided and incremental changes and I think

0:02:01.369,0:02:09.640
here the key part is the incremental changes
because more often than not when we have new

0:02:09.640,0:02:14.910
features that are coming or there are new
requests from the business they are quite

0:02:14.910,0:02:20.000
chunky so they start to say I would like to
connect your system with this third party

0:02:20.000,0:02:28.740
and then evolve the computation adding new
functionalities and anything. What you need

0:02:28.740,0:02:35.590
to think about every time is trying to break
down those let's say complex requests in smaller

0:02:35.590,0:02:40.530
units that are deliverable and that's why
evolution architecture can really help us

0:02:40.530,0:02:49.159
to achieve that So I think everyone at least
once has to deal with the 3-tier software

0:02:49.159,0:02:54.220
architecture the 3-tier software architecture
is composed by three layers the first one

0:02:54.220,0:03:00.370
is a presentation layer you have dynamic application
layer where all the business logic leaves

0:03:00.370,0:03:06.459
and then you have a data layer where basically
you store your data but the problem when you

0:03:06.459,0:03:12.180
deal with this kind of architecture that is
still valid. I see a lot of let's say that's

0:03:12.180,0:03:16.010
still a lot of

0:03:16.010,0:03:20.580
implementation with pretty architecture nowadays.
The problem is that in the long run what usually

0:03:20.580,0:03:25.879
happens is there is a leak of domain between
the data layer and presentation layer towards

0:03:25.879,0:03:31.750
the application layer. What it means is basically
sometimes when you need to implement a feature

0:03:31.750,0:03:39.500
and you are under pressure or time constraints
you start to take this code and start to let's

0:03:39.500,0:03:45.800
say do some create some tech debt. The problem
is more often than not is difficult then to

0:03:45.800,0:03:52.640
remember about the tech debt or to let's say
fix the tech debt and sooner rather than later

0:03:52.640,0:04:01.879
the application layer became of information
that shouldn't leave in that specific layer

0:04:01.879,0:04:10.320
the other thing that I have experienced firsthand
was moving some workloads to AWS Lambda so

0:04:10.320,0:04:17.139
imagine that you have for instance your container
living on AWS ccs or you have your application

0:04:17.139,0:04:22.250
running in a virtual machine. In this *case
ec2 and you want to move everything to lambda

0:04:22.250,0:04:29.720
the complexity if the code is not well structured
is extracting a portion of a domain and move

0:04:29.720,0:04:38.440
to the lambda now this despite it could let's
say seem simple a simple problem to solve

0:04:38.440,0:04:44.190
it results that is not especially when you
don't plan upfront on creating some code that

0:04:44.190,0:04:50.880
is modular enough for being decoupled and
then you will be able to easily move between

0:04:50.880,0:04:51.919
different compute services.

0:04:51.919,0:04:59.120
The third point that they want to make is
more often than not when you're looking for

0:04:59.120,0:05:04.740
example or lambdas or maybe you have some
numbers that are written similar to to this

0:05:04.740,0:05:11.090
one you find this kind of code and usually
what you have is inside your lambda handler

0:05:11.090,0:05:18.270
you have like all these code that contains
basically the retrieval of the request from

0:05:18.270,0:05:24.669
the body in this case of a post request and
then you have like submit candidate p that

0:05:24.669,0:05:32.669
is basically the function in the middle of
this image and candidate info so those two

0:05:32.669,0:05:38.229
those two basically functions what they do
is submit candidate p is communicating with

0:05:38.229,0:05:47.069
the database instead candidate info is containing
information around the domain so what we want

0:05:47.069,0:05:52.300
to store inside the database but as you can
see here there is a mix and match of incoming

0:05:52.300,0:05:58.210
requests parsing validation and then you have
like in integration with infrastructure and

0:05:58.210,0:06:03.009
so so forth if we want to evolve this kind
of code it becomes complicated mainly because

0:06:03.009,0:06:08.069
we need them to test every single bit end
to end to make sure that we didn't introduce

0:06:08.069,0:06:16.759
any bug and that is a very let's say challenging
problem. Because when you are working in a

0:06:16.759,0:06:22.259
large system if you have multiple of those
implementations. you risk that you jeopardize

0:06:22.259,0:06:28.349
your velocity and throughput because you basically
are living in a code that is very tightly

0:06:28.349,0:06:36.250
coupled together. So **examiner** architecture
is trying to solve that. Alistair Cockburn

0:06:36.250,0:06:41.900
is the creator of Hexagonal Architecture but
also co-signs the agile manifesto. so it's

0:06:41.900,0:06:48.460
a person that really gives a lot to the software
community who created the Hexagonal Architecture

0:06:48.460,0:06:57.090
with one thing in mind. trying to find a way
to decouple the business logic from the environment

0:06:57.090,0:07:03.220
where it's running. And that basically provides
some nice side effects the first one is that

0:07:03.220,0:07:08.580
you can drive your application in different
ways it could be like a batch script it could

0:07:08.580,0:07:15.210
be a unit test it could be let's say a request
from a service. but because you modularized

0:07:15.210,0:07:22.900
very well your code. you don't risk to pollute
the business logic in a way that then became

0:07:22.900,0:07:30.310
unflexible and therefore you need to spend
a lot of time to evolve it.

0:07:30.310,0:07:35.810
the other thing that I want to
focus is understanding deeply how Hexagonal

0:07:35.810,0:07:36.810
Architecture works.

0:07:36.810,0:07:42.090
so let's take a look at the anatomy of a Hexagonal
Architecture. so the first if you want to

0:07:42.090,0:07:48.789
layer or **exit learning** this in this case
is the domain logic the main logic is basically

0:07:48.789,0:07:55.640
what you want to achieve inside your AWS Lambda
the beauty of applying Hexagonal Architecture

0:07:55.640,0:08:01.330
on lambda is that because lambda by design
is not let's say a very complex environment

0:08:01.330,0:08:05.680
so you have like a small amount of logic if
you encapsulate very well your domain logic

0:08:05.680,0:08:11.930
it became easier to test and evolve it without
too many problems the second layer is the

0:08:11.930,0:08:18.660
ports and ports are basically the entry point
for the external world towards the domain

0:08:18.660,0:08:25.520
logic. And also are the way how the domain
logic is interacting with the external world

0:08:25.520,0:08:32.000
and finally you have adapters.
adapters as the name suggest it's taken from

0:08:32.000,0:08:38.250
the idea of the adapter pattern the basically
is a way that two different **contracts**

0:08:38.250,0:08:43.940
are communicating together the role of the
adapters is basically becoming your anti-corruption

0:08:43.940,0:08:50.030
layer between the external world. and your
business logic and is also translating what

0:08:50.030,0:08:54.480
is coming from the external world towards
the internal world. the communication between

0:08:54.480,0:08:57.980
domain logic and adapters is happening always
through ports.

0:08:57.980,0:09:03.480
this architecture is also called port and
adapter so you can hear hexagon architecture

0:09:03.480,0:09:09.980
**or ports and adapter they mean the same
thing the interesting part of these is the

0:09:09.980,0:09:15.800
ports could depend on the language that they
are using it could be just an interface and

0:09:15.800,0:09:20.860
therefore an adapter is implementing an interface
for communicating with domain logic. or it

0:09:20.860,0:09:23.730
could be like in the example that we are going
to see

0:09:23.730,0:09:30.070
a function I'm going to use node.js with es6
so javascript and not typescript but with

0:09:30.070,0:09:38.460
type languages like java or c-sharp or typescript
you can use interfaces.

0:09:38.460,0:09:42.160
the  other part that you need to be aware
on the

0:09:42.160,0:09:44.190
Hexagonal Architecture is that you have primary
actors.

0:09:44.190,0:09:50.060
The primary actors are the ones that are communicating
with your AWS Lambda in this case inside your

0:09:50.060,0:09:57.880
Hexagonal Architecture. what they are it could
be another microservice it could be a client

0:09:57.880,0:10:02.820
it could be a message inside the queue because
the lambda can be called synchronously or

0:10:02.820,0:10:08.110
asynchronously and then you can have secondary
actors that basically are the actors that

0:10:08.110,0:10:14.520
are used by our code for I don't know for
instance retrieving information from a database

0:10:14.520,0:10:20.500
consuming a service a third party service
or adding a message in a queue. so those are

0:10:20.500,0:10:26.950
basically the key point on how you are going
to structure your Hexagonal Architecture.

0:10:26.950,0:10:34.540
that obviously is valid for AWS Lambda but it could
be valid also with the container or with the virtual  machine

0:10:34.540,0:10:38.840
bear in mind currently, the focus of this
talk will be on lambda because I think these

0:10:38.840,0:10:43.165
architectures specifically can really shine
inside the serverless paradigm.

0:10:43.165,0:10:48.400
the benefit and drawbacks.
so benefit is the business logic is agnostic

0:10:48.400,0:10:53.510
to the outside world and that is absolutely
great because it means that we have we can

0:10:53.510,0:11:00.080
evolve it and change it without affecting
the rest of the code it's independent of external

0:11:00.080,0:11:05.690
service therefore for the business logic it doesn't matter if we are using a SQL database or no SQL database.

0:11:05.690,0:11:10.360
 what it matters for the
business logic is that it's going to request

0:11:10.360,0:11:17.140
some information to a repository and then
the adapter encapsulate all the logic for

0:11:17.140,0:11:22.990
interacting with that repository. and that
allows you to really evolve your code in a

0:11:22.990,0:11:33.750
way that it's better for everyone. then it's
easier to test and test in isolation especially

0:11:33.750,0:11:38.810
and we will see more in this talk and finally
is reducing the technical debt the fact that

0:11:38.810,0:11:45.440
you spend a bit of time upfront defining those
boundaries and those modules will allow you

0:11:45.440,0:11:52.440
to run faster in the long run. at the same
time on the pitfalls or drawbacks, you need

0:11:52.440,0:11:56.060
to spend more time thinking about building
multiple layers because you need to create

0:11:56.060,0:12:02.500
adapters ports and business logic, and in
the original implementation-defined by Alistair Cockburn,

0:12:02.500,0:12:11.060
there weren't too many references
on how to structure your business logic that

0:12:11.060,0:12:19.380
is not necessarily a negative thing but it
means that you have an opportunity for let's

0:12:19.380,0:12:25.440
say use your knowledge and your style for
encapsulating better the code inside your

0:12:25.440,0:12:33.980
business logic. so if by now you're thinking
okay why a Hexagonal why not another shape

0:12:33.980,0:12:38.640
Alistair Cockburn is providing also the answer
for that. the hexagonal is not the meaning

0:12:38.640,0:12:46.930
of how many sides we need in a shape. but
it's just a good way to represent the complexity

0:12:46.930,0:12:53.420
that a specific service could be could interact
with. before we just rectangles we didn't

0:12:53.420,0:12:58.440
have enough space for drawing all the interactions
that the service could be exposed to. and

0:12:58.440,0:13:02.690
nowadays with microservices, this is becoming
even more important.

0:13:02.690,0:13:09.506
because you may have multiple interactions
as a primary or secondary actor.

0:13:09.506,0:13:17.190
so I prepare a demo on this. and what we are going to see
is this it's a very simple demo but provides

0:13:17.190,0:13:24.400
you the idea of what we can really do with
this approach. So first of all, you have an

0:13:24.400,0:13:31.290
API gateway that is exposing an API. 
The API is basically every time you call this rest

0:13:31.290,0:13:35.090
API you trigger an AWS Lambda that is called
the stock  converter

0:13:35.090,0:13:41.620
and as the name suggests what expects is a
stock id and when you receive the stock id

0:13:41.620,0:13:47.092
is going to retrieve the value of the stock
id from the stocks table that is a DynamoDB table.

0:13:47.092,0:13:54.210
and then is going to call a third party service
where it is going to retrieve real-time all

0:13:54.210,0:14:00.770
the currencies and then when it has that two-piece
information the business logic is going to

0:14:00.770,0:14:07.430
apply the currencies to the stock value and
return back the value of the stock in multiple

0:14:07.430,0:14:13.690
currencies that's basically what we're going
to see. And when we see in slow motion how

0:14:13.690,0:14:16.450
the interaction would work

0:14:16.450,0:14:23.500
So first of all you will have an HTTP request.
the adapter will pick the HTTP request and

0:14:23.500,0:14:30.130
through the port is going to communicate with
the business logic passing the stock id.

0:14:30.130,0:14:36.050
Then the business logic as the first thing is going
to call a port and say to the port please

0:14:36.050,0:14:41.070
retrieve this stock id. and the port knows
that has to communicate without an adapter

0:14:41.070,0:14:47.730
then the adapter is communicating with DynamoDB
because it is encapsulating inside it all

0:14:47.730,0:14:53.370
the information related to DynamoDB and then
the business logic triggers another action

0:14:53.370,0:14:57.940
that is calling through an adapter as through
a port another adapter that is communicating

0:14:57.940,0:15:03.910
with the currency service that is a third
party service and then it returns everything.

0:15:03.910,0:15:10.820
So let's go back to our IDE and let's try
to see what we have here.

0:15:10.820,0:15:14.620
Okay so this is the structure of my project
as you can see here I have a folder for adapters

0:15:14.620,0:15:19.760
domain and ports usually you it depends how
you want to structure you can potentially

0:15:19.760,0:15:25.520
divide also this part per domain and have
like one business domain that contains sport

0:15:25.520,0:15:32.470
adapters and and business logic in my opinion
because we are working with lambda we are

0:15:32.470,0:15:38.430
already reducing the scope of of the domain
so in theory you should be able to structure

0:15:38.430,0:15:44.260
the code with just adapters domain ports but
it's completely up to you how you want to do that.

0:15:44.260,0:15:49.540
the if we see how the the logic the
the code works based on the logic that I just

0:15:49.540,0:15:56.240
explained this is the entry point of our lambda
okay so we have like literally not much here

0:15:56.240,0:16:01.690
because what we have is the lambda that is retrieving
the stock id from the url and then is passing

0:16:01.690,0:16:08.070
this information to this adapter that is called
that has a function called get stock request

0:16:08.070,0:16:12.920
get stock request once again in this case
is a primary adapter this is coming from the

0:16:12.920,0:16:18.820
primary actor and what it does is just calling
it doesn't have to do validation on anything

0:16:18.820,0:16:26.110
it's just calling a a function for inside
a port and is when he receives the response

0:16:26.110,0:16:34.920
it will drop the final with a response to
the to the client if we go inside then the

0:16:34.920,0:16:42.010
port. the port as I said before but is important
to iterate is as simple as a function in javascript

0:16:42.010,0:16:47.200
if you have typescript or any other type language
you can use an interface so the port basically

0:16:47.200,0:16:54.000
what it does in this case is exposing a function
and is communicating with a business logic

0:16:54.000,0:16:57.980
why we're doing this because in this case
now we have the adapter that is completely

0:16:57.980,0:17:03.720
decoupled from the business logic therefore
we can evolve those two entities as we

0:17:03.720,0:17:10.650
want without risking to let's say having a
side effect that are bubbling between between

0:17:10.650,0:17:16.350
different layers as long the contours will
remain the same we are in a good shape so

0:17:16.350,0:17:23.070
in the business logic once again here we have
all the currencies that they want to to use

0:17:23.070,0:17:28.290
so in this case is American dollars Canadian dollars
Australian dollars but the important

0:17:28.290,0:17:34.870
thing is that I have other two action to do.
First I call this repository port that will

0:17:34.870,0:17:40.870
communicate with a repository in this case
DynamoDB through the adapter for retrieving

0:17:40.870,0:17:48.350
the stock id. When I retrieve the stock id
I will then call the currencies. Therefore

0:17:48.350,0:17:54.240
a third party service for doing so and then
I will apply the logic that I explained before

0:17:54.240,0:18:02.630
for let's say applying the currency to the
original stock value. great so let's go for

0:18:02.630,0:18:09.030
the repository. so the repository is a port
and as a port it it just has a function that

0:18:09.030,0:18:14.970
calls an adapter. the adapter is get stockman.
this is a secondary adapter because it's calling

0:18:14.970,0:18:22.910
is handled basically by our AWS function and
here as you can see what we have is all the

0:18:22.910,0:18:30.750
information related on how to retrieve a specific
item from the database. if I want to change

0:18:30.750,0:18:36.890
the schema. if I want to change the way
I'm querying the database or the way how i'm

0:18:36.890,0:18:37.930
I don't know

0:18:37.930,0:18:45.610
writing data in the database in a hypothetical
thing. the only thing that they need to change

0:18:45.610,0:18:53.090
is this partner. And that is one of the benefit
of working with this with this approach now

0:18:53.090,0:18:59.300
if we go back to our business logic the other
interesting part is what we are going to do

0:18:59.300,0:19:06.930
with the currencies. and the currencies has
these get that this port is called get currency

0:19:06.930,0:19:12.420
data and then it goes to to retrieve the currencies.
here we have a point-to-point communication

0:19:12.420,0:19:17.230
with a third party service and that's it. 
we retrieve the information we send back to

0:19:17.230,0:19:23.780
the to the business logic and business logic
knows how to do. By now you understand that

0:19:23.780,0:19:29.130
the business logic doesn't know who requested
this information it could be api gateway it

0:19:29.130,0:19:34.240
could be unit test it doesn't matter for the
business logic and it doesn't care even if

0:19:34.240,0:19:40.880
it's communicating with a sql or nosql database
or where is the endpoint that we are retrieving

0:19:40.880,0:19:45.860
information therefore we encapsulated very
well the business logic and can evolve as we prefer.

0:19:45.860,0:19:54.590
Now let's play a game let's think
about a new scenario you deploy this AWS Lambda

0:19:54.590,0:20:00.120
in a production and your service starts to
get a lot of traction so people are extremely interesting to that.

0:20:00.120,0:20:08.140
And what happens then
is that you basically start to see some errors

0:20:08.140,0:20:15.540
coming out from your lambda because the third
party service is not capable to cope up with

0:20:15.540,0:20:21.370
the traffic the request per second that you
have from your service. You need to figure

0:20:21.370,0:20:27.150
out a way to solve that. Obviously it's a third
party service so you cannot say listen can

0:20:27.150,0:20:32.500
you increase by I don't know 10x the amount
of requests that they have because they have

0:20:32.500,0:20:38.630
let's say their own architecture and they
or they their own things to handle therefore

0:20:38.630,0:20:44.280
usually you have a limited amount of requests
that you can have. Okay so the other

0:20:44.280,0:20:49.020
alternative is that you handle on your side.
so in this case what we can do instead of

0:20:49.020,0:20:57.050
doing is using this adapter we can I created
a new adapter that is called currency converter

0:20:57.050,0:21:03.300
with cache. And here as you can see I have
exactly the same signature. So the same function

0:21:03.300,0:21:09.540
the same contract but what they have added
here is a elastic cache with redis that is

0:21:09.540,0:21:17.390
a service available in AWS for using a managed
version of redis cluster. And the beauty of

0:21:17.390,0:21:23.640
this approach is that basically i'm implementing
a cache inside my logic so here the logic

0:21:23.640,0:21:32.360
would be first thing first check inside redis
If I stored any currency and if I do return

0:21:32.360,0:21:40.560
back to the client without making any call
to the third party service and to a certain

0:21:40.560,0:21:46.020
extent this is great. Because that means i'm
offloading dramatically all the traffic that

0:21:46.020,0:21:50.680
is going to the third party service because
i'm using the cache. If the cache is evicted

0:21:50.680,0:21:58.780
is empty I have the possibility to call the
third party service. and then I immediately

0:21:58.780,0:22:04.550
store the information retrieved from the third
party service inside radis and I set an eviction

0:22:04.550,0:22:12.480
policy of 20 seconds. After 20 seconds automatically
redis will evict the cache and you can go ahead

0:22:12.480,0:22:19.130
with let's say querying again the third party
service for training fresh data this approach

0:22:19.130,0:22:24.950
scaled pretty well because as you can imagine
if you have 10 lambdas that are let's say

0:22:24.950,0:22:31.770
querying the database simultaneously then
you go with these 10 lambdas you are

0:22:31.770,0:22:35.720
going to hit the vast majority of the time
red is more than third party service so that

0:22:35.720,0:22:45.750
is great. Okay so we have seen how to structure
the code in *ojs and how it works now another

0:22:45.750,0:22:51.700
example that I want to add on this scenario
again. So imagine now that instead of having

0:22:51.700,0:22:56.960
a lambda the team that was working on this
was starting from a container and therefore

0:22:56.960,0:23:02.930
docker container in this case. So in this case
this is the code that I need to do as you

0:23:02.930,0:23:08.820
can see here I have the same folders with
the same files okay nothing nothing different

0:23:08.820,0:23:14.480
so I copy and paste those inside this new
application. I have a different obviously entry

0:23:14.480,0:23:18.980
point because this is my web server in node
called fastify.  It's a well-known framework

0:23:18.980,0:23:26.500
in node.js and the interesting part is this
the entry point is exactly the same what it

0:23:26.500,0:23:31.341
means though it means that basically imagine
that you have a crowd application where you

0:23:31.341,0:23:39.320
are creating updating writing and reading
and deleting elements inside the database

0:23:39.320,0:23:45.340
I will have obviously multiple of those methods
so if we structure the code in a modular fashion

0:23:45.340,0:23:51.640
we can extract portion of the code and move
to a lambda without any problem and that is

0:23:51.640,0:23:57.390
the power of this approach we can also move
between compute services very easily because

0:23:57.390,0:24:01.809
we modularize the code in a way that would
allow us to have this flexibility to evolve

0:24:01.809,0:24:06.680
our code based on the business needs

0:24:06.680,0:24:11.520
okay so let's go back to the slides and let's
start to think about other use cases because

0:24:11.520,0:24:17.510
that those are some of them but there are
more. So the first one is testing and isolation

0:24:17.510,0:24:24.030
As I said before now the business logic is
well encapsulated and that means potentially

0:24:24.030,0:24:27.990
you can have a faster feedback loop when you're
writing code. Imagine that you are writing

0:24:27.990,0:24:32.840
your code and you have your business logic
is well isolated you can even separate how

0:24:32.840,0:24:38.330
you're running your code in a way that when
you connect to a database unless you are often

0:24:38.330,0:24:44.120
changing schema it is not going to happen
very often. That code will be solid so

0:24:44.120,0:24:48.800
you need you don't need to test but the business
logic would evolve and therefore what you

0:24:48.800,0:24:55.300
can do is running dividing the test for the
adapters and the business logic in your development

0:24:55.300,0:25:00.360
environment. And then testing more often the
business logic or the part that is evolving

0:25:00.360,0:25:05.680
more and therefore having a faster turnaround
on the rest and then doing more extensive

0:25:05.680,0:25:12.240
tests when you are about to open up a request
or whatever. But this really speed up the way

0:25:12.240,0:25:18.110
how you are doing tests. The cache inside
pattern is the one that we have seen before

0:25:18.110,0:25:22.140
so we implement the redis cache and it's very
similar so you have the service that is it

0:25:22.140,0:25:27.220
in your lambda and then the land is communicating
with the database. In order to offload or a

0:25:27.220,0:25:31.670
third party service in order to offload the
request because maybe some of the queries

0:25:31.670,0:25:36.440
are always the same you can add the cache
and depends obviously from database to database

0:25:36.440,0:25:40.990
that you're going to use if you're using dynamo
you can use *DAX that is another service that

0:25:40.990,0:25:47.780
is let's say fully managed and allows you
to have a cache layer in front of dynamo.

0:25:47.780,0:25:53.240
But if you want you can use elastic cache with
radis and it's completely up to you on

0:25:53.240,0:25:58.309
memory db that is a new service that we launched
very recently. The other thing is imagine that

0:25:58.309,0:26:02.700
you want to change the trigger so the way
how your application works. So instead of having

0:26:02.700,0:26:08.850
an api gateway that is calling the lambda
function now you want to have an asynchronous

0:26:08.850,0:26:15.590
model where the api gateway is storing the
request directly to SQS so a queue and then

0:26:15.590,0:26:21.809
the the lambda is trigger in batches so it
takes like few elements inside the queue start

0:26:21.809,0:26:28.260
to process them and then behind the scene
the client is starting to have a request.

0:26:28.260,0:26:34.630
A polling mechanism or a socket for understanding
when the computation is accomplished

0:26:34.630,0:26:38.930
so those kind of things are easy to implement because
in this case the only change that you're going

0:26:38.930,0:26:44.340
to make as long as the computation remains
the same is that the primary adapter

0:26:44.340,0:26:48.700
so you basically change the adapter in a way that
instead of receiving the request from api gateway

0:26:48.700,0:26:55.030
has to extract the data from the from
SQS and that is great because it means that

0:26:55.030,0:27:00.940
basically we don't have to change anything
on our business logic

0:27:00.940,0:27:06.330
another scenario is service migration. so imagine
that you have a lambda that is communicating

0:27:06.330,0:27:11.540
with a self-managed mobile database and at
some point you realize that you spend too

0:27:11.540,0:27:16.400
much time on maintaining this database and
you want to move to a managed database version

0:27:16.400,0:27:23.113
so in this case it could be AWS DocumentDB
that is let's say powering one with the db in the scene

0:27:23.113,0:27:27.830
the beauty of this approach is
that like once again you go you're going to

0:27:27.830,0:27:32.350
change just the adapters for the piece of
logic doesn't care if it's MongoDB or DocumentDB

0:27:32.350,0:27:38.130
and also you can apply certain migration
patterns that you wouldn't be able to do so

0:27:38.130,0:27:43.678
so despite you obviously when you do immigration
or database you need to find a way to migrate the data

0:27:43.678,0:27:48.809
But then on the business logic side
you can use for instance a branch by abstraction

0:27:48.809,0:27:54.860
pattern that basically is allowing you to
run those two things in parallel and maybe

0:27:54.860,0:27:59.130
for a certain period of time just to make
sure that all the data are synchronized properly

0:27:59.130,0:28:04.000
you check on mongodb the responses that are
coming from DocumentDB. And then when you

0:28:04.000,0:28:09.486
are confident you just move ahead but that
is a really great use case.

0:28:09.486,0:28:16.170
The other thing is modern web application modernization so
imagine that you have your monolithic architecture

0:28:16.170,0:28:22.250
and you start to divide that by different
subdomains and then those domains usually

0:28:22.250,0:28:27.360
in software architecture as some new one
described multiple times this is called a

0:28:27.360,0:28:32.100
modular monolate when you have a monolithic
code base that is divided by sub domains

0:28:32.100,0:28:36.370
what you can do is basically preparing yourself
for migrating to microservices and that is

0:28:36.370,0:28:41.540
going to help because when you divide with
Hexagonal  Architecture your code the immutable

0:28:41.540,0:28:46.600
subdomains then is easy to extract portion
in multiple microservices and the same thing

0:28:46.600,0:28:53.951
is going to happen when we do from microservices to lambda. 
The interesting approach here for me is this one

0:28:53.951,0:29:00.090
so the fact that you have a
microservice with multiple obviously endpoints

0:29:00.090,0:29:07.440
that are running there. you can extract some
of them in lambdas based on the volumetric

0:29:07.440,0:29:11.640
that you're going to receive so for instance
if your microservice has a lot of reads but

0:29:11.640,0:29:17.450
not many writes and many delete and update.
what you could do potentially as a first step

0:29:17.450,0:29:25.250
is instead of going with full lambdas one
per rest verb or http verb. you are going

0:29:25.250,0:29:30.010
to have one for read that has a different
scale button compared to the others and one

0:29:30.010,0:29:34.559
for the other three actions. And then when
you see that there is a real need for let's

0:29:34.559,0:29:41.770
say moving away and from maintaining these
three and let's say other http verb in the

0:29:41.770,0:29:46.660
same lambda you can slowly but study migrating
but you gain you're gaining immediately the

0:29:46.660,0:29:51.940
serverless benefit because you move away from
having a managed container

0:29:51.940,0:29:59.250
then finally hybrid strategies and that is
an interesting one right because sometimes

0:29:59.250,0:30:05.240
you have some workloads that require your
code to run in two environments maybe on-prem

0:30:05.240,0:30:13.600
and on on the cloud and an example is if you
have your Hexagonal Architecture. what you could

0:30:13.600,0:30:19.980
do potentially is running your AWS Lambda
in AWS. And then have the same business logic

0:30:19.980,0:30:28.220
running on Knative. Knative is a kubernetes offering for 
serverless that could run everywhere to be honest

0:30:28.220,0:30:32.309
the beauty of this approach is
that you write once the business logic and

0:30:32.309,0:30:39.520
then you basically start to spread the so
the test is just once and you are really

0:30:39.520,0:30:44.283
making sure that everything is working. the
only thing that you are going to change probably are the adapters

0:30:44.283,0:30:49.221
 and as long as you maintain
the same contract the only effort that you

0:30:49.221,0:30:55.284
have is maintaining the adapters in AWS and
in Knative that is in my opinion absolutely fantastic.

0:30:55.284,0:31:02.750
Finally there is one real let's
say niche and esoteric if you want architecture

0:31:02.750,0:31:08.370
that i'm quite interested on but it's still
early days. it's called Petalith architecture

0:31:08.370,0:31:14.020
the concept of Petalith architecture is basically
having the possibility to work with microservices

0:31:14.020,0:31:21.740
at the development time but deploy in smaller
units when you go on the cloud in this

0:31:21.740,0:31:26.640
case so what it means is that I'm developing
a microservice and my another team is developing

0:31:26.640,0:31:31.920
another one and because they're in the same
domain I can merge them at compile time and

0:31:31.920,0:31:41.380
send all together inside a unique *piece to
instance or whatever.  This is still let's say

0:31:41.380,0:31:47.800
early days and there are quite a few researches
around that. But it's something that I i wanted

0:31:47.800,0:31:54.100
to add just to give you an idea that where
also exactly architecture can shine.

0:31:54.100,0:31:59.640
I've seen an implementation that is using a library
node.js library called microlib that what

0:31:59.640,0:32:07.270
it does is using these and even going further
where you can reload at runtime your code

0:32:07.270,0:32:13.400
directly inside your *accident that is quite
interesting obviously still early days so

0:32:13.400,0:32:17.922
don't take this tomorrow production, but
definitely keep an eye on it.

0:32:17.922,0:32:29.046
so obviously exactly architecture started was let's say
released in 2005 so a big time ago.

0:32:29.046,0:32:35.751
And since then there were some evolution 
So the first one is this one is onion architecture

0:32:35.751,0:32:42.120
that what it does is solving the problem that
we were describing before trying to create

0:32:42.120,0:32:51.600
a more structured and opinionated business
logic. And the same was it happened in 2012

0:32:51.600,0:33:00.330
where uncle bob they introduced the clean
architecture that is very dissimilar to

0:33:00.330,0:33:07.200
the online one but with different let's say
entities and constructs. The interesting part

0:33:07.200,0:33:14.920
here for me is if we're talking about with
a monolithic code base. I see the need of structuring

0:33:14.920,0:33:22.000
the better the business logic totally I can
see thaNt on the lambda in theory if you structure

0:33:22.000,0:33:27.870
properly your lambdas and you're not going
to have a very complex lambdas using just

0:33:27.870,0:33:34.040
Hexagonal Architecture as i've shown you during
this session I think would be more than enough

0:33:34.040,0:33:41.620
because otherwise you start to go too granular
and you know talking with a customer it was

0:33:41.620,0:33:48.000
telling me we we went to the clean architecture
route for microservices and it was a proliferation

0:33:48.000,0:33:53.150
of files that at the end was difficult to
manage in the long run. And I totally agree

0:33:53.150,0:33:57.990
so you need to find the right balance and
the right trade-off despite yes there are

0:33:57.990,0:34:03.730
some other more structured architectures 
but I believe that *exaggerated architecture as

0:34:03.730,0:34:11.900
I showed you it should be enough for your
serverless workers. so now the question probably

0:34:11.900,0:34:21.250
after this this session is this the definitive
architecture that AWS encourage for developing lambda

0:34:21.250,0:34:28.369
the answer is it depends. As a good
architect I couldn't say yes or no because

0:34:28.369,0:34:34.399
it really depends from the context.
architecture is always based on trade-offs it doesn't exist

0:34:34.399,0:34:40.340
the right or wrong. But the only thing that
exists is that your context has some requirements,

0:34:40.340,0:34:47.230
and based on the requirements you take a decision.
now what I see really shining this architecture

0:34:47.230,0:34:54.260
is when for instance you have a workload that
has to evolve during the time. imagine for

0:34:54.260,0:34:59.340
instance that you are developing a software
as a service or you have an internal product

0:34:59.340,0:35:05.510
that you need to maintain for years and years
and years. definitely investing a bit of time

0:35:05.510,0:35:12.710
on structuring your code with the Hexagonal architecture
can can really help. On the other side if you

0:35:12.710,0:35:18.570
have for instance a project that should stay
online for I don't know a couple of months

0:35:18.570,0:35:24.780
because maybe it's an event starting with
the exact architecture probably is an overkill

0:35:24.780,0:35:30.359
same when you have like a service that is
not doing much is maybe a service that is

0:35:30.359,0:35:37.480
just I don't know calling a a third party
or basically it's a proxy between two elements

0:35:37.480,0:35:41.740
starting with the Hexagonal architecture
probably is an overkill but there are let's

0:35:41.740,0:35:47.180
say situation where it can really shine for
me the important thing that for me is it should

0:35:47.180,0:35:53.150
be that your main takeaway is try to understand
deeply your context find the what are the

0:35:53.150,0:35:58.400
characteristics of your architecture and then
based on that take the decision if external

0:35:58.400,0:36:06.369
architecture could help you on your serverless
workload or not. So just to wrap up.

0:36:06.369,0:36:11.690
so we have seen that we have a strong separation 
of concern with the external architecture then we have

0:36:11.690,0:36:16.010
seen that infrastructure is fully decoupled
from the business logic so we can evolve both

0:36:16.010,0:36:22.110
in parallel and potentially with let's say
different people or even you can evolve taking

0:36:22.110,0:36:28.000
different direction without any problem. 
Hexagonal architecture is easy to test thanks to the

0:36:28.000,0:36:33.310
two characteristics that I mentioned before
and finally there are many use cases where

0:36:33.310,0:36:39.330
that are simplified when we use etc architecture
therefore if for any given reason you know

0:36:39.330,0:36:45.990
that some of the use cases that I mentioned
are going to happen no fear not because you

0:36:45.990,0:36:53.080
will be able to cover that. I gather in this
life that we share later on quite a few links

0:36:53.080,0:36:59.990
you can find the demo that I showed you
on github and you have also I wrote

0:36:59.990,0:37:05.690
an article based on on this example what I
described that is available in the compute

0:37:05.690,0:37:12.119
blog of AWS and you can read basically what
I described during this talk. and then I have

0:37:12.119,0:37:18.300
you have a bunch of other links like the original
article on hexagonal architecture the only architecture

0:37:18.300,0:37:24.050
clean architecture and so on. that's it for
me thank you very much I'm more than happy

0:37:24.050,0:37:29.510
to jump on some questions. And if you want
to contact me because later on you have other

0:37:29.510,0:37:33.619
questions or anything. that is my email so
feel free to contact me anytime I respond

0:37:33.619,0:37:38.810
to everyone. so thank you very much

0:37:38.810,0:37:45.570
okay thanks, Luka hey wait wait

0:37:45.570,0:37:55.430
thanks, Luka well that's very informational
and knowledgeable presents. okay so the next

0:37:55.430,0:38:02.370
one will go to the QnA session. if you haven't
asked the question yet please go to the slido

0:38:02.370,0:38:07.859
and post your question and you can upload
your favorite one so that we can see that

0:38:07.859,0:38:10.590
more clearly. I'll choose that one

0:38:10.590,0:38:17.060
let me see

0:38:17.060,0:38:24.826
okay look how can you could you see the slide
on my screen okay cool. yeah great

0:38:24.826,0:38:33.310
so let me choose the first one, okay the first one is
doing the Hexagonal Architecture must go with

0:38:33.310,0:38:41.119
AWS Lambda. the way it decoupled ports and adapters
from business logics seems to fit in on-premise

0:38:41.119,0:38:49.470
service as well. okay you can go
- Yeah totally so the Hexagonal architecture it doesn't work

0:38:49.470,0:38:55.350
only with lambda it works with containers
it works with any type of code is an architecture

0:38:55.350,0:39:04.270
pattern right. I think Hexagonal architecture
was well discussed for

0:39:04.270,0:39:14.360
for a long long long time inside the community
and this is not let's say a *novel thing but

0:39:14.360,0:39:19.359
I thought that currently I didn't see many
talking about Hexagonal architecture properly

0:39:19.359,0:39:26.190
on AWS Lambda. and I think with the AWS Lambda
where more often than not because it's a small

0:39:26.190,0:39:33.520
entity we tend to just write everything inside
the handler is a good pattern for helping

0:39:33.520,0:39:43.130
the development of serverless let's say architectures
creating a well structure mechanism that

0:39:43.130,0:39:50.600
at least is well known and also is easy to implement 
so definitely you can run on-premise

0:39:50.600,0:39:54.950
you can run a container you can run wherever you want

0:39:54.950,0:40:02.200
- okay okay thank you and yeah let's actually
this is my first time too. here we can mix

0:40:02.200,0:40:07.440
we can mix hexagon architecture with lambda
okay that's very interesting and we can see

0:40:07.440,0:40:17.109
lots more potentials for AWS lambda.
okay next one okay so is the currency converter service

0:40:17.109,0:40:27.371
thread-safe? i'm a serverless TFC member
I know the answer but I guess attendees want to know that.

0:40:27.371,0:40:32.760
I believe so so I don't believe it would

0:40:32.760,0:40:41.119
be not safe so yes I think the answer is yes
- yeah cool that's a sweet show and comfort

0:40:41.119,0:40:47.900
and it comes yeah good answer.
the next one can we take Hexagonal Architecture as the

0:40:47.900,0:40:52.188
idea of clean architecture in cloud-based
service

0:40:52.188,0:40:58.121
- yeah totally you can use these 
architecture for lambda for whatever

0:40:58.121,0:41:03.490
the other two architectures that I mentioned like onion and clean

0:41:03.490,0:41:08.731
are I mentioned them mainly because
sometimes when you go online and you start

0:41:08.731,0:41:13.197
to research around the Hexagonal architecture
they bubble up very often.

0:41:13.197,0:41:18.870
and people start to say oh this is an Hexagonal architecture
and it's true technically speaking they are

0:41:18.870,0:41:24.619
Hexagonal architecture or whether is not the original
implementation are more structured version

0:41:24.619,0:41:29.530
of the Hexagonal architecture that are taking
all the characteristics of *Hexagonal architecture

0:41:29.530,0:41:35.283
and then adding on top of that a more structured business logic.

0:41:35.283,0:41:42.283
- yeah I agree. all those architectures they share some common characteristics . yeah okay next one

0:41:42.283,0:41:53.190
so someone is very curious about could you explain
more about the Petalith architecture

0:41:53.190,0:42:01.760
and explain characteristics.
- yeah so the name Petalith is coming from one of

0:42:01.760,0:42:10.820
our colleagues in AWS agent Cockroft that
is that was the chief architect in netflix

0:42:10.820,0:42:16.668
he migrated basically the netflix architecture
towards cloud and microservices

0:42:16.668,0:42:28.730
and now is working in AWS on the sustainability part
so his idea basically is trying to decouple

0:42:28.730,0:42:33.040
the try to reduce let's say the complexity
on the infrastructure or maintaining infrastructure

0:42:33.040,0:42:38.040
but maintaining the same flexibility that
you have with microservices at development

0:42:38.040,0:42:44.390
time and the idea is it's pretty interesting
if you think about that because compute and

0:42:44.390,0:42:51.550
resources are becoming extremely cheap so
if we are capable to say okay instead of having

0:42:51.550,0:42:58.900
a *proliferation of microservices all over
my accounts. I start to have less of them more

0:42:58.900,0:43:05.460
if you want infrastructure wise macro services
and then I although I i have a very *granular

0:43:05.460,0:43:11.270
approach on on the way how i'm developing
and then the basically the infrastructure

0:43:11.270,0:43:18.150
part is completely decoupled by the development
phase so I don't map one *team to one microservice

0:43:18.150,0:43:24.400
or one api to my microservices whatever it
is I map a domain to a bunch of microservices

0:43:24.400,0:43:29.590
I have the benefit of using microservices
they're for distributed teams that are empowered

0:43:29.590,0:43:35.740
to make changes atomically but on the other
side I have less to maintain on the infrastructure

0:43:35.740,0:43:41.109
because there are less things that could go
wrong everything maybe a specific a specific

0:43:41.109,0:43:46.090
domain could live inside the same machine
and therefore the communication is even not

0:43:46.090,0:43:52.320
affected by latency and other things so the
concept is pretty interesting I think is it

0:43:52.320,0:44:01.030
may break some other ideas that in the community
are well known by now. but it's definitely

0:44:01.030,0:44:06.877
an interesting architecture and i'm keeping
an eye on it because I want to see how it's going to evolve.

0:44:06.877,0:44:13.780
- yeah thank you that's cool
okay I think we still have some time okay

0:44:13.780,0:44:20.840
so let me go through the next question cool
the next one is when we apply lambda

0:44:20.840,0:44:29.270
to make the microservice.
what things will meet problem and the risk yeah

0:44:29.270,0:44:37.570
so at the end lambda is a think about that
is running inside a container. so if you have

0:44:37.570,0:44:44.040
already a containerized microservice let's
say you should have too many troubles obviously

0:44:44.040,0:44:49.570
it depends what you're doing inside the microservice
if you're doing some special things like using

0:44:49.570,0:44:56.250
specific I don't know extensions or anything
you need to apply carefully them on lambda

0:44:56.250,0:45:01.820
wherever it's totally doable. 
but that is not a problem the beauty of of lambda is

0:45:01.820,0:45:09.150
usually that you try to split up in a modular
fashion what you have in a microservice so

0:45:09.150,0:45:13.880
in the example that was making before having
a *crowd operation where you are decoupling

0:45:13.880,0:45:21.000
basically the read from the right operation
inside your system you can have for instance

0:45:21.000,0:45:28.070
two lambdas you can even even add more if
you want to scale in a different *fashion

0:45:28.070,0:45:36.030
the risk I would say on top of my head I would
say that the main risk that you may have is

0:45:36.030,0:45:43.200
some patterns that are not manageable by you
so for instance if you say I know up front

0:45:43.200,0:45:51.760
that i'm going to have I don't know five millions
of requests per second on a microservice

0:45:51.760,0:45:59.520
then you can say okay I prepare everything
upfront in my containers and I warm up everything

0:45:59.520,0:46:04.740
I add more machine than needed and so on so
forth with lambda you have a server you have

0:46:04.740,0:46:11.240
a feature that allows you to have a pre-warm
of your lambda. but then you are living inside

0:46:11.240,0:46:15.830
your the constraint basically provided by
the service because it's this fully managed

0:46:15.830,0:46:19.780
service of a compute part and therefore you
can increase the amount of lambda you can

0:46:19.780,0:46:24.290
have per account but definitely there are
some quotas that you need to be aware and

0:46:24.290,0:46:30.710
you need to when you design your workload
be very aware to understand how your traffic

0:46:30.710,0:46:31.210
pattern should be implemented inside the serverless
solution I think that is the main thing

0:46:31.210,0:46:41.685
but what you can do in a server in microservices
you can do also in a serverless application

0:46:41.685,0:46:48.280
- yes thank you yeah I agree that. however no
matter how you what kind of a technique you

0:46:48.280,0:46:55.859
use you are using make sure you understand
its limits and its ability yeah okay next

0:46:55.859,0:47:02.580
one the live demo is really cool and well
explained i'm curious how to explain the advantage

0:47:02.580,0:47:08.400
of the architecture that is easy
to understand for business people yeah that's

0:47:08.400,0:47:15.680
quite a big challenge.
- yeah thanks for the praise on the demo thanks for that

0:47:15.680,0:47:24.510
so I think there are a few points so the first
one would be the possibility to to evolve

0:47:24.510,0:47:32.030
their needs faster. they less introduction
of production bugs that already are a big

0:47:32.030,0:47:43.260
advantage. and the fact that you can really
drift the direction of a system quickly because

0:47:43.260,0:47:50.160
yes there is an initial investment but if
in the code that you have seen. I really have

0:47:50.160,0:47:56.050
a small amount of code that working as a solo
developer or even in a team it became extremely

0:47:56.050,0:48:00.741
easy to atomically say okay we need to make
this feature you take care about the adapter

0:48:00.741,0:48:05.560
I take care about the business logic so you
can really parallelize the work in a nice way

0:48:05.560,0:48:11.030
and if you are disciplined enough or
maintaining this structure during the

0:48:11.030,0:48:18.410
life cycle of the project. you would be able
really to follow and expand the need of things

0:48:18.410,0:48:24.700
and probably the first thing could be innovation
so if you want to try one thing quickly you

0:48:24.700,0:48:31.130
just try that and you let's say dropping away
inside your code that is modular enough that

0:48:31.130,0:48:35.350
we you can immediately test it. and then if
it doesn't work you can remove at the same speed

0:48:35.350,0:48:41.890
so you have innovation you have a faster
turnaround on new features and you have less

0:48:41.890,0:48:47.347
bugs in production. I think just these three
characteristics should be enough for for business people

0:48:47.347,0:48:53.500
- yeah I agree that look I think the
only thing the business people only care about

0:48:53.500,0:49:00.490
is could you deliver your product or products
more frequently more faster and more safely

0:49:00.490,0:49:08.470
yeah that's all are we concerned about cool
the final one or finally the final one is

0:49:08.470,0:49:14.790
could you list some main aspects that make
you choose Hexagonal Architecture from others

0:49:14.790,0:49:27.090
- yes, so the the main choice for me is when I have a project 
they need to maintain in the long run

0:49:27.090,0:49:32.359
so for instance imagine that
you want to run a quick POC just to a proof

0:49:32.359,0:49:38.910
of concept just to make sure that your idea
is working. that probably I wouldn't go with

0:49:38.910,0:49:44.570
with an Hexagonal architecture. But then when
you want to really implement your code and

0:49:44.570,0:49:50.450
you are working on a product that has to you
are going to maintain for six months one year

0:49:50.450,0:49:56.740
whatever is where usually I will look
into it especially for serverless because

0:49:56.740,0:50:02.400
in other architecture so if you in for other
more monolithical code bases like for container

0:50:02.400,0:50:07.780
whatever there are plenty of architectures
out there that you can use the beauty of this

0:50:07.780,0:50:14.460
is that you can really test in isolation
certain parts and the fact that you can

0:50:14.460,0:50:22.050
let's say structure the code in a very
modular fashion. so for me in the lambda if

0:50:22.050,0:50:26.750
or already by design it shouldn't have too
much scope inside the lambda so it's very

0:50:26.750,0:50:33.990
easy to create. but if we had also *examined
architecture evolving that became easier and

0:50:33.990,0:50:39.320
and so for me the the rule of thumb would
be is it code that I have to thrown away

0:50:39.320,0:50:45.040
after a while or is it the code that
I am not going to use for for long term or

0:50:45.040,0:50:49.210
is this very very small action that I need
to do inside my lambda that probably I won't

0:50:49.210,0:50:55.880
use *Hexagonal architecture. for the rest of
the use cases yes say it's a bit more investment

0:50:55.880,0:51:02.250
but it's not definitely that it's going to
take twice the time for for writing in Lambda

0:51:02.250,0:51:09.520
- yeah I agree I think every investment has
its own risk and you can always start small

0:51:09.520,0:51:15.900
but if you want to go feather maybe you can
consider other things like Hexagonal Architecture

0:51:15.900,0:51:22.720
and you want to have a more scalability and
you want to have more. you want to involve

0:51:22.720,0:51:29.060
your models quickly maybe you can consider
Lambda and Hexagonal Architecture okay so

0:51:29.060,0:51:32.350
thank you Luka again and very happy to have
you here
