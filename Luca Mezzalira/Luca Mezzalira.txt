evolutionary fws lambda with hexagonal architecture um

um

hello hello nice to meet you likewise yeah okay so now it's your time so you can start at any time perfect fantastic thank you very much for the introduction uh and sorry a bit for my voice i have a bit of code so uh it would be a bit weird my voice but don't worry i will do my best that you you will be able to enjoy the talk so today i'm going to talk about aws lambda but specifically how to modularize your code in order to have a let's say a system that would be able to follow the drifts that uh the business would uh it is looking for because in reality every business is evolving and is changing direction and we have some ways as architects and developers that will allow us to follow their direction and improve and evolve our architecture following uh the right business direction my name is luca magdalera i'm a principal solution architect at aws i'm an international speaker and an o'reilly author so let's start with defining what evolutionary architectures are and directly from the book building evolutionary architecture that if you didn't read uh trust me is a really great book um you can see that evolution architecture supports guided and incremental changes and i think here the key part is the incremental changes because uh more often than not when we have like new features that are coming or there are new requests from from the business they are quite chunky so they start to say i would like to connect your system with this third party and then evolve uh the um computation adding new functionalities and anything what you what you need to think about every time is trying to break down those uh let's say complex requests in smaller units that are deliverable and that's why evolution architecture can really help us to achieve that so i think everyone at least once uh have to deal with the three years after architecture the free tier software architecture is composed by three layers the first one is a presentation layer you have dynamic application layer where all the business logic leaves and then you have a data layer where basically you store your your data but the problem when you deal with this kind of architecture that is still valid uh i i see a lot of uh let's say uh that's still a lot of um um implementation with with pretty architecture nowadays the problem is that in the long run what usually happens is there is a leak of domain between the data layer and presentation layer towards the application layer what it means is basically sometimes when you need to implement a feature and you are under pressure or time constraints uh you start to take this code and and start to uh let's say do some create some tech debt uh the problem is more often than not is difficult then to remember about the tech depth or to uh let's say fix the tech depth and sooner rather than later the application layer became obliterated of information that shouldn't leave in that specific layer the other thing that um i have experienced firsthand was moving some workloads to to aws london so imagine that you have for instance your container living on aws ccs or you have your application running in a virtual machine in this case ec2 and you want to move everything to lambda the complexity if the code is not well structured is extracting a portion of a domain and move to the london now this despite it could uh let's say seem simple a simple problem to solve uh it results that is not especially when you don't plan upfront on creating some code that is modular enough for being decoupled and then you will be able to easily move between different compute services the third point uh that they want to make is uh more often than not when you're looking for example or lambdas or maybe you have some numbers that are written uh similar to uh to this one um you find this kind of code and usually what you have is inside your hand lambda handler you have like all these code that contains basically the um retrieval of uh the the request from the body uh in this case of a post of a post request and then you have like submit candidate p that is basically the um function uh in the middle of this image and candidate info so those two um those two basically functions what they do is submit candidate p is communicating with the database instead candidate info is containing information around the domain so what we uh want to store inside the database but as you can see here there is a mix and match of uh incoming requests parsing validation uh and then you have like in integration with infrastructure and so so forth if we want to evolve this kind of code it becomes complicated mainly because we need them to test every single bit end to end to make sure that we didn't introduce any bug and that is a very uh let's say challenging problem because when you are working in large system if you have multiple of those implementation you you risk that you jeopardize your velocity and throughput because you basically are living in a code that is very tightly coupled together so examiner architecture is trying to solve that alistar cockburn that is the creator of alexander architecture but also co-sign the agile manifesto so it's a person that really give a lot to to the software community created the examiner architecture in with one thing in mind trying to find a way to decouple uh the business logic from the environment where it's running and that basically uh provides some nice side effects the first one is that you can drive your application uh in different ways it could be like a batch script it could be a unit test it could be uh let's say a request from a service but because you modularized very well your code you don't risk to pollute the business logic uh in in a way that then became uh unflexible and therefore you need to spend a lot of time to evolve it

um the other thing uh that i want to to focus is understanding deeply how hexagonal architecture works so let's take a look to the anatomy of an examiner attraction so the first if you want layer or exit learning this in this case is the domain logic the main logic is basically what you want to achieve inside your aws london the beauty of of applying examiner architecture on lambda is that because lambda by design is is not let's say a very complex environment so you have like a small amount of logic if you encapsulate very well your domain logic it became easier to test and evolve it without too many problems second layer is the ports and ports are basically the entry point for the external world towards the domain logic and also are the way how the domain logic is interacting with the external world and finally you have adapters adapters as the name suggests uh is uh uh taken from the idea of the adapter pattern the basically is a way that uh two different contracts are communicating together the role of the adapters is basically becoming your anti-corruption layer between the external world and your business logic and is also translating what is coming from the external world towards the internal world the communication between domain logic and adapters is happening always through ports this architecture is also called port and adapter so you can hear hexagon architecture okay airport adapter they mean the same thing the um interesting part of these is the ports could be uh depends on the language that they are using it could be just an interface and therefore an adapter is implementing an interface for communicating with domain logic or it could be like in the example that we are going to see uh a a function i'm going to use node.js with uh es6 so javascript and not typescript but we type language type language like java or c-sharp or uh typescript you can use interfaces the other part that you need to be aware on the exact architecture is that you have primary actors the primary actors are the ones that are communicating with your aws lambda in this case inside your examiner architecture what they are it could be another microservice it could be a client it could be a message inside the queue because the lambda can be called synchronously or asynchronously and then you can have secondary actors that basically are the actors that are used by our code for uh i don't know for instance retrieving information from a database consuming a service a third party service or adding a message in a queue so those are basically the key point on how you are going to to structure your exaggerator architecture that obviously is valid for aws lambda but it could be valid also with the container or with the virtual machine bear in mind currently the focus of this talk will be on lambda because uh i think these architectures specifically can really shine inside the serverless paradigm the benefit and drawbacks so benefit is the business logic is agnostic to the outside world and that is absolutely great because it means that we have we can evolve it and change it without affecting the rest of the code it's independent from external service therefore for the business logic it doesn't matter if we are using a sql database or no sql database what it matters for the business logic is that it's going to request some information to a repository and then the adapter encapsulate all the logic for interacting with that repository and that allows you to really evolve your code in a way that it's a better for for everyone then um it's easier to test and test in isolation especially and we will see more in this talk and finally is reducing the technical debt the fact that you spend a bit of time upfront defining those boundaries and those modules will allow you to run faster in the long run at the same time on the pitfalls or drawbacks you need to spend more time thinking on building multiple layers because you need to create adapters ports and business logic and in the original implementation defined by alistar cockburn there weren't too many references on how to structure your business logic that is not uh necessarily a negative thing but it means that you have an opportunity for uh let's say use your knowledge and your style for encapsulating better the code inside your business logic so if by now you're thinking okay why an accident why not not another shape alistar cockburn is providing also the answer for that the hexagon is not the meaning of how many how many sides we need uh in a shape but it's just a good way to represent the complexity that a specific service could be could interact with before we just rectangles we didn't have enough space for drawing all the interaction that the service could be exposed to and nowadays with microservices this is becoming even more important uh because um you you may have multiple interaction as a primary or secondary actors so i prepared a demo uh on on this and what we are going to see is this is a very simple demo but provides you the idea of what we can really do with this approach so first of all you have an api gateway that is exposing an api the api is basically every time you call this rest api you trigger an aws lambda that is called stock converter and as the name suggests what expects is a stock id and when you receive the stock id is going to retrieve the value of the stock id from the stocks table that is a dynamodb table and then is going to call a third party service where it is going to retrieve real-time all the currencies and then when it has those two piece informations the business logic is going to apply the currencies to the stock value and return back the value of uh the stock in multiple currencies that's basically what we're going to see and when we see in slow motion uh how the interaction would work so first of all you will have an http request the adapter will pick the http request and through the port is going to communicate with the business logic passing the stock id then the business logic as the first thing is going to call a port and saying to the port please retrieve this uh stock id and the port knows that has to communicate without an adapter then the adapter is communicating with dynamodb because it is encapsulating inside it all the information related to dynamodb and then the business logic triggers another action that is calling through an adapter as a through a port another adapter that is communicating with the currency service that is a third party service and then it returns everything so let's go back to uh our ide and let's try to see what we have here okay so this is the structure of my project as you can see here i have a folder for adapters domain and ports um usually you it depends how you want to structure you can potentially divide also this part per domain and have like one business domain that contains sport adapters and and business logic uh in my opinion because we are working with lambda we are already reducing the scope of of the domain so in theory you should be able to structure the code with just adapters domain ports but it's completely up to you how you want to do that the uh if we see how the the uh logi the the code works based on the logic that i just explained this is the entry point of our lambda okay so we have like literally not much here because what we have is the lamb that is retrieving the stock id from the url and then is passing this information to this adapter that is called that has a function called get stock request get stock request once again in this case is a primary adapter this is coming from the primary actor and what it does is just calling it doesn't have to do validation on anything it's just calling a a function for inside a port and is when he receives the response it will drop the uh final um with a response to the uh to the client if we go inside then the port the port as i said before but is important to iterate is as simple as a function in javascript if you have typescript or any other type language you can use an interface so the port basically what it does in this case is exposing a function and is communicating with a business logic why we're doing this because in this case now we have the adapter that is completely decoupled from the business logic therefore we can evolve those two entities as as we want without risking to uh let's say having a side effect that are bubbling between between different layers as long the contours will remain the same we are in a good shape so in the business logic uh once again here we have all the currencies that they want to uh to use so in this case is american dollars canadian dollars australian dollars uh but the important thing is that i have other two uh action to do first i call this repository port that will communicate with a repository in this case dynamodb uh through the adapter uh for retrieving the stock id when i retrieve the stock id i will then call the currencies therefore a third party service for doing so and then i will apply the logic that i explained before for uh let's say applying the currency to the original stock value great so um let's go for the repository so the repository is a port and as a port uh it it just has a function that calls an adapter the adapter is get stockman this is a secondary adapter because it's calling is handled basically by our aws function um and here as you can see what we have is all the information related on how to retrieve a specific item from the database if i want to change the schema if i want to change the way i'm i'm querying the database or the way how i'm i don't know

writing data in the database in a hypothetical thing the only thing that they need to change is this partner and that is one of the benefit of working with this with this approach now if we go back to our business logic the other interesting part is what we are going to do with uh the currencies and the currencies has these get that this port is called get currency data and then it goes to to retrieve the currencies here we have a point-to-point communication with a third party service and that's it so we retrieve the information we send back to the uh to the business logic and business logic knows how to do by now you understand that the business logic doesn't know how who requested this information it could be api gateway it could be unit test it doesn't matter for the business logic and it doesn't care even if it's communicating with a sql or nosql database or where is the endpoint that we are retrieving information therefore we encapsulated very well the business logic and can evolve as we prefer now let's play a game let's think about a new scenario you deploy this aws lambda in a production and your service starts to get a lot of traction so people are extremely interesting to that and what happens then is um that you uh basically start to see uh some uh errors coming out from your uh lambda because the third party service is not capable to cope up with the traffic uh the request per second that you have uh from your service you need to figure out a way to solve that obviously it's a third party service so you cannot say listen can you increase by i don't know 10x the amount of requests that they have because they have let's say their own architecture and they or they um their own uh things to to to handle therefore usually you have a limited amount of requests that you can you can have okay so the other alternative is that you handle on your side so in this case what we can do instead of doing is using this adapter we can i created a new adapter that is called um currency converter with cache and here as you can see i have exactly the same signature so the same function the same contract but what they have added here is a elastic cache with redis that is a service available in aws for using a managed version of redis cluster and the um beauty of this approach is that basically i'm implementing a cache inside my my logic so here the logic would be first thing first check inside radius if i stored any currency and if i do return back to the client without making any call to um to the third party service and to a certain extent this is great because that means i'm offloading dramatically all the traffic that is going to the third party service because i'm using the cash if the cash is evicted is empty uh i have the possibility to call the third party service and then i immediately store the information retrieved from the third party service inside radis and i set an eviction policy of 22nd after 20 seconds automatically redis will evict the cash and you can go ahead with let's say querying again the third party service for training fresh data this approach scaled pretty well because as you can imagine if you have 10 landers that are let's say querying the database simultaneously then you go uh you go with these 10 lambdas you are going to hit the vast majority of the time red is more than third party service so that is great okay so we have seen uh uh how to structure the code in ojs and how it works now another example that i want to add on this uh scenario again so imagine now that instead of having a lambda the team that was working on this was starting from a container and therefore docker container in this case so in this case this is the code that i need to do as you can see here i have the same folders with the same files okay nothing nothing different so i copy and paste those inside this new application i have a different obviously entry point because this is my web server in node called fastify it's a well-known framework in node.js and uh the interesting part is this the entry point is exactly the same what it means though it means that basically imagine that you have a crowd application where you are creating updating writing and reading uh and deleting elements inside the database i will have obviously multiple of those methods so if we structure the code in a modular fashion we can extract portion of the code and move to a lambda without any problem and that is the power of this approach we can also move between compute services uh very easily because we modularize the code in a way that would allow us to have this flexibility to evolve our code based on the business needs

okay so let's go back to the slides and let's start to think about other use cases because that those are some of them but there are more so the first one is testing and isolation as i said before now the business logic is well encapsulated and that means potentially you can have a faster feedback loop when you're writing code imagine that you are writing your code and you have your business logic is well isolated you can even separate how you're running your code in a way that when you connect to a database unless you are often changing schema it is not going to happen very often uh you that code will be solid so you need you don't need to test but the business logic would evolve and therefore what you can do is running dividing the test for the adapters and the business logic in your uh development environment and then testing more often the business logic or the part that is evolving more and therefore having a faster turnaround on the rest and then doing more extensive tests uh when you are about to open up a request or whatever but this really speed up the way how you are doing testing the cache inside pattern is the one that we have seen before so we implement the redis cache and it's very similar so you have the service that is it in your lambda and then the land is communicating with the database in order to offload or a third party service in order to offload the request because maybe some of the queries are always the same you can add the cache and depends obviously from database to database that you're going to use if you're using dynamo you can use dax that is another service that is let's say fully managed and allows you to have a cache layer in front of dynamo but if if you want you can use elastic cache with uh radis and it's completely up to you on memory db that is a new service that we launched very recently the other thing is imagine that you want to change the trigger so the way how your application works so instead of having an api gateway that is calling the lambda function now you want to have an asynchronous model where the api gateway is storing the request directly to uh sqs so a queue and then the the lambda is trigger uh in batches so it takes like few elements inside the queue start to process them and then behind the scene the client is starting to have um a request a polling mechanism or a socket for understanding when the computation is accomplished so those kind of things are easy to implement because in this case the only change that you're going to make as long as the computation remains the same is that the primary adapter so you basically change the adapter in a way that instead of receiving the request from api gateway has to extract the data from the from sqs and that is great because it means that basically we don't have to change anything on our business logic

another scenario is service migration so imagine that you have a lamb that is communicating with a self-managed mobile database and at some point you realize that you spend too much time on maintaining this database and you want to move to a managed database version so in this case it could be aws documentability that is let's say powering one with the bb in the scene the uh beauty of this approach is that like once again you go you're going to change just the adapters for the piece of logic doesn't care if it's mongodb or document b and also you can apply certain migration patterns that you wouldn't be able to do so so despite you obviously when you do immigration or database you need to find a way to migrate the data but then on the business logic side you can use for instance a branch by abstraction pattern that basically is allowing you to run those two things in parallel and maybe for a certain period of time just to make sure that all the data are synchronized properly you uh check on mongodb the responses that are coming from document db and then when you are confident you just uh move ahead but that is a really great use case the other thing is modern web application modernization so imagine that you have your monolithic architecture and you start to divide that by different subdomains and then those domains usually in in software architecture as some new one described multiple times this is called a modular monolate when you have a monolithic code base that is divided by sub domains what you can do is basically preparing yourself for migrating to microservices and that is going to help because when you divide with examiner architecture your code the immutable sub domains then is easy to extract portion in multiple microservices and the same thing is going to happen when we do from microservices to london the interesting approach here for me is this one uh so the fact that you have a microservice with multiple obviously uh endpoints that are running there you can extract some of them in lambdas based on the volumetric that you're going to receive so for instance if your microservice has a lot of reads but not many writes and many delete and update what you could do potentially as a first step is uh instead of going with four lambdas one per uh h rest verb or http verb you are going to have one for read that has a different scale button compared to the others and one for the other three actions and then when you see that there is a real need for let's say moving away and from maintaining these three uh and let's say other http verb in the same lambda you can slowly but study migrating but you gain you're gaining immediately the serverless benefit because you move away from uh having a managed container

then finally hybrid strategies and that is an interesting one right because sometimes you have some workloads that require your code to run in uh two environments maybe on-prem and uh on on the cloud and an example is if you have your uh examiner architecture what you could do potentially is running your aws lambda in aws and then have the same business logic running on k native okay native is a kubernetes offering for serverless that could run um everywhere to be honest the beauty of this approach is that you write once the business logic and then you basically start to spread the um so the test is just once and you you are really making sure that everything is working the only thing that you are going to change probably are the adapters and as long as you maintain the same contract the only effort that you have is maintaining the adapters in aws and in kenya that is in my opinion absolutely fantastic finally there is one real let's say niche and esoteric if you want architecture that i'm quite interested on but it's still early days it's called patholith architecture the concept of patholith architecture is basically having the possibility to work with microservices at the development time but deploy in smaller units when you go on uh on the cloud in this case so what it means is that i'm developing a microservice and my another team is developing another one and because they're in the same domain i can merge them at compile time and send um all together inside a unique piece to instance or whatever um this is still let's say early days and there are quite a few researches around that but it's something that i i wanted to add just to give you an idea that where also exactly architecture can shine i've seen an implementation that uh is using a library node.js library called microlib that what it does is using these and even going further where you can reload at runtime uh your code directly inside your accident that is uh quite interesting obviously still early days so uh don't take this tomorrow introduction but definitely keep an eye on it so obviously uh exactly architecture started um was let's say released in 2005 so a big time ago uh and uh since then there were some evolution so the first one is uh this one is this uh onion architecture uh that uh what it does is solving the problem that we were describing before trying to create a more structured and opinionated uh business logic uh and the same was uh it happened in 2020 2012 where um uncle bob uh they introduced the clean architecture that is very dissimilar uh to to the online one but with different uh let's say entities uh and uh constructs the interesting part here for me is uh if we're talking about uh with a monolithic code base i see the need of um structuring the better the business logic totally i can see that uh on the lambda in theory if you structure properly your lambdas and you're not going to have a very complex lambdas using just hexagonal architecture as i've shown you uh during this uh session i think would be more than enough because otherwise you start to go too granular and you know um talking with a customer uh it was telling me we we went to the clean architecture route for microservices and it was a proliferation of files that at the end was difficult to manage in the long run and i totally agree so you need to find the right balance and the right trade-off despite yes there are some other uh more structured architectures but i believe that exaggerated architecture as i showed you uh it should be enough for your serverless workers so now the question uh probably after this um this session is uh is this the definitive architecture that aws encourage for uh developing uh lambda the answer is it depends as a good architect i couldn't say yes or no because uh it really depends from the context architecture is always based on trade-offs it doesn't exist the right or wrong but the only thing that exists is that your context has some requirements and based on the requirements you take a decision now what i see uh really uh shining this architecture is when for instance you have a workload that has to evolve uh during the time imagine for instance that you are developing a software as a service or you have an internal product that you need to maintain for years and years and years definitely investing a bit of time on structuring your code with the exact architecture can can really help on the other side if you have uh for instance a project that should stay online for i don't know a couple of months because maybe it's an event starting with the exact architecture probably is an overkill same when you have like a service that is not doing much is maybe a service that is just i don't know uh calling a a third party or uh basically it's a proxy between two elements starting with the exact architecture probably probably is an overkill but there are uh let's say situation where it can really shine for me the important thing that for me is it should be that your main takeaway is try to understand deeply your context find the what are the characteristics of your architecture and then based on that take the decision if uh external architecture could help you on your serverless workload or not so just to wrap up uh so we have seen that we have a strong separation of concern with the external architecture then we have seen that infrastructure is fully decoupled from the business logic so we can evolve both in parallel and potentially with let's say different people or even you can evolve taking different direction without any problem exactly architecture is easy to test thanks to the two characteristics that i mentioned before and finally there are many use cases where that are simplified when we use uh etc architecture therefore if for any given reason you know that uh some of the use cases that i mentioned are going to happen no fear not because you will be able to cover that uh i gather in this life that we share later on quite a few links uh you can find the demo that i showed you uh on gitla on github and you have also i wrote an article based on on this example what i described uh that is available in the compute blog uh of aws and you can read basically what i described during this talk and then i have you have a bunch of other uh links like uh the original article on exam architecture the only architecture clean architecture and so on that's it for me thank you very much i'm more than happy to jump on uh some questions and if you want to contact me because later on you have other questions or anything that is my email so feel free to contact me anytime i respond to everyone so uh thank you very much

okay thanks luke hey wait wait

thanks zuka well that's very informational and knowledgeable uh presents okay so the next one will go to the qna session if you haven't asked the question yet please go to the slider and and post your question and you can upload your favorite one so that we can see that more clearly i'll choose that one

let me see

okay uh look how can you could you see the the slide on my screen okay cool yeah great so let me choose the first one okay the first one is does the hexagonal architecture must go with aws london the way it decoupled protein adapters from business lodges seems to fit in on premise service as well okay you can go yeah totally uh so the exact architecture it doesn't work only with lambda it works with containers it works with any type of code is an architecture button right i uh i think exactly architecture was well discussed for

for a long long long time inside the the community and this is not let's say a novel thing but i i thought that currently i didn't see many talking about exact architecture properly on aws lambda and i think with the ws lambda where more often than not uh because it's a small entity we tend to just write everything inside inside the handler is a good pattern for helping uh the development of of serverless let's say architectures creating a wealth structure mechanism that at least is well known and also uh is easy to to implement so definitely you can run on premise you can run a container you can run wherever you want

okay okay thank you and yeah let's uh actually this is my first time too here we can mix uh we can mix hexagon architecture with lambda okay that's very interesting and we can see lots more potentials for aws lander okay next one okay so is the currency converter service through it safe i'm a serverless tfc member i know the answer but i guess attended attendees once you know it no less against my office i i believe so uh so i i don't believe it would be uh not safe so yes i think the answer is yes yeah cool that's a sweet show and comfort and it comes yeah good answer the next one can we take hexagonal architecture as the idea of clean architecture in cloud-based service yeah totally uh you can use these architecture for lambda for whatever they they the other two architectures that i mentioned like onion and clean are i mentioned them mainly because sometimes when you go online and you start to research around the external architecture they they bubble up uh very often and people start to say oh this is an exacto architecture and it's true technically speaking they are exotic architecture however is not the original implementation are more structured version of the hexagon architecture uh that are taking all the characteristics of example architecture and then adding on top of that a more structured business logic yeah i agree then all those architectures they share some common correct curricular receipts yeah okay next one so someone is very curious about could you explain more about the pathways architecture um yeah and explore curriculum characteristics yeah so the name patholet is coming from one of our colleagues in aws um adrian uh cockroft uh that is that was the uh chief architect in netflix he migrated basically the netflix architecture towards um cloud and microservices uh and now is working in aws uh on the sustainability uh part so his idea basically is trying to uh decouple um the try to reduce let's say the complexity on the infrastructure or maintaining infrastructure but maintaining the same flexibility that you have with microservices at development time and the idea is it's pretty interesting if you think about that because compute and resources are becoming extremely cheap uh so if we are capable to say okay instead of having a proliferation of micro services all over my accounts i start to have less of them more if you want infrastructure wise macro services and then i although i i have a very granular approach on on the way how i'm developing and then the basically the the the infrastructure part is completely decoupled uh by the development phase so i don't map one theme to one microservice or one api to my microservices whatever it is i map a domain to a bunch of microservices i have the benefit of using microservices they're for distributed teams that are empowered to make changes atomically but on the other side i have less to maintain on the infrastructure because there are less things that could go wrong uh everything maybe a specific um a specific domain could live inside the same machine and therefore the communication is even uh not affected by latency and other things so the concept is pretty interesting uh i think is it may break some other uh ideas that in the community are well known by now but uh it's uh it's definitely an interesting architecture and i'm keeping an eye on it because i want to see how it's going to evolve yeah thank you that's cool okay i think we still have some time okay so let me go through the next question cool the next one is when we apply line the lambda to make the it make the micro service what things will meet problem and the risk yeah so at the end uh lambda is a think about that is running inside a container so if you have already a containerized micro service uh let's say you should have too many troubles obviously it depends what you're doing inside the microservice if you're doing some special things uh like using specific uh um i don't know extensions or anything uh you need to apply carefully them on on lambda wherever it's totally doable uh but that that is not a problem the beauty of of lambda is usually that you try to uh split up in a modular fashion what you have in a micro service so in the example that was making before having a crowd operation where you are decoupling basically uh the read from the right operation inside your system you can have for instance two lambdas you can even even add more if you want to scale in a different fashion um the the risk i would say um on top of my head i would say that the main risk that you may have is some uh patterns that are not manageable by you so for instance uh if uh you say uh i know up front that uh i'm going to have um i don't know uh five millions of requests per second uh on on a microservice then you can say okay i uh prepare everything upfront uh in my containers and i warm up everything i add more machine than needed uh and so on so forth with lambda you have a server you have a feature that allows you to have a pre worm of your lambda but then you are living inside your the constraint basically provided by the service because it's this fully managed service of a compute part and therefore you can increase the amount of lambda you can have per account uh but definitely there are some quotas that you need to be aware and you need to when you design your workload be very aware to understand how your traffic pattern should be implemented inside the serverless solution i think that is the main thing but what you can do in a server in microservices you can do also in a serverless application yes thank you yeah i agree that um however no matter how you uh what kind of a technique you use you are using make sure you understand its limits and its ability yeah okay next one the live demo is really cool and well explained i'm curious how to explain the advantage of the architecture that is easy that is easy to understand for business people yeah that's quite a big challenge yeah uh thanks for uh for the praise on on the demo thanks for that uh so uh i think there are a few points so the first one would be um the possibility to uh to evolve their needs faster they less introduction of uh production bugs that already are a big advantage uh and the fact that you can really drift uh the direction of a system quickly because yes there is an initial investment but if in the code that you have seen i really have a small amount of code that working as a solo developer or even in a team it became extremely easy to atomically say okay we need to make this feature you take care about the adapter i take care about the business logic so you can really parallelize the work in a nice way and if you are disciplinated enough or maintaining this structure uh during the the life cycle of the project you would be able really to uh follow and expand the need of things and probably the first thing could be uh innovation so if you want to try one thing quickly you just try that and you uh let's say dropping away inside your code that is modular enough that we you can immediately test it and then if it doesn't work you can remove at the same speed so you have innovation you have a faster turnaround on new features and you have less bugs in production i think just these three characteristics should be enough for for business people yeah i agree that look i think the only thing the business people only care about is could you deliver your product or products uh more frequently more faster and more safely yeah that's all are we concerned about cool the final one or finally the final one is could you list some main aspects that make you choose hexagonal architecture from others

um yes so the the main choice for me is when um when i have a project they need to maintain in the long run so for instance imagine that you want to run a quick poc just to a proof of concept just to make sure that uh your idea is working that probably i wouldn't go with uh with uh an external architecture but then when you want to really implement your code and you are working on a product that has to you are going to maintain for six months one year whatever is where usually i will i will look into it especially for serverless because in other architecture so if you in for other more monolithical code bases like for container whatever there are plenty of architectures out there that you can use the beauty of this is that you you can um really test in isolation certain parts and and the fact that you can uh um um let's say structure the code in a very modular fashion so for me in the lambda if uh or already by design it shouldn't have too much scope inside the lambda so it's very easy to do to create but if we had also examined architecture evolving that became easier uh and uh and so for me the the rule of thumb would be is it is it code that i have to thrown away after a while or is it the code that i am not going to use for for long term or is this very very small action that i need to do inside my alarm that probably i won't use external architecture for the rest of the use cases yes say it's a bit more uh investment but it's not definitely that it's going to take twice the time for uh for writing in london yeah i agree i think every investment has its own risk and you can always start small but if you want to go farther maybe you can consider other things like hexagonal architecture and you want to have a more scalability and you want to have more um do you want to involve your models quickly maybe you can consider london and hexagonal architecture okay so thank you luka again and very happy to have you here